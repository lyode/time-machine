<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Voice Assistant - Your Intelligent Companion</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .aurora-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 107, 157, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(138, 43, 226, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(30, 144, 255, 0.4) 0%, transparent 50%);
            animation: aurora 15s ease-in-out infinite;
            pointer-events: none;
            transition: opacity 2s ease-out;
        }

        @keyframes aurora {
            0%, 100% { opacity: 0.6; transform: scale(1) rotate(0deg); }
            33% { opacity: 0.8; transform: scale(1.1) rotate(1deg); }
            66% { opacity: 0.4; transform: scale(0.9) rotate(-1deg); }
        }

        .main-content {
            text-align: center;
            position: relative;
            z-index: 1;
            max-width: 650px;
            padding: 50px 40px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(25px);
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.3);
            transition: all 2s ease-out;
        }

        .title {
            font-size: 3.2rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #ff6b9d, #c44bd1, #4a90e2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            animation: shimmer 3s ease-in-out infinite;
            line-height: 1.1;
        }

        @keyframes shimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }

        .subtitle {
            font-size: 1.3rem;
            margin-bottom: 30px;
            opacity: 0.9;
            color: #ff6b9d;
            font-style: italic;
            font-weight: 300;
        }

        .description {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 50px;
            opacity: 0.85;
            color: #e8e8e8;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }

        .launch-button {
            display: inline-block;
            padding: 25px 50px;
            background: linear-gradient(135deg, #ff6b9d, #c44bd1);
            color: white;
            text-decoration: none;
            border-radius: 60px;
            font-size: 1.4rem;
            font-weight: 700;
            transition: all 0.4s ease;
            box-shadow: 0 15px 40px rgba(255, 107, 157, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
            margin-bottom: 40px;
            letter-spacing: 0.5px;
            cursor: pointer;
        }

        .launch-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.6s;
        }

        .launch-button:hover::before {
            left: 100%;
        }

        .launch-button:hover {
            transform: translateY(-4px) scale(1.08);
            box-shadow: 0 20px 50px rgba(255, 107, 157, 0.7);
            background: linear-gradient(135deg, #ff7ba3, #d056d9);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .launch-button:active {
            transform: translateY(-2px) scale(1.05);
        }

        .button-icon {
            margin-right: 12px;
            font-size: 1.5rem;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .features {
            text-align: left;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 25px;
            padding: 35px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
        }

        .features h3 {
            color: #ff6b9d;
            margin-bottom: 20px;
            font-size: 1.4rem;
            text-align: center;
            font-weight: 600;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            list-style: none;
            padding: 0;
        }

        .feature-item {
            padding: 12px 0;
            padding-left: 30px;
            position: relative;
            font-size: 1rem;
            line-height: 1.5;
            color: #e8e8e8;
            transition: color 0.3s ease;
        }

        .feature-item::before {
            content: '‚ú®';
            position: absolute;
            left: 0;
            color: #ff6b9d;
            font-size: 1.2rem;
            animation: sparkle 3s ease-in-out infinite;
        }

        .feature-item:nth-child(even)::before {
            animation-delay: 1.5s;
        }

        @keyframes sparkle {
            0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.7; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 1; }
        }

        .floating-elements {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            transition: opacity 2s ease-out;
        }

        .floating-element {
            position: absolute;
            color: rgba(255, 107, 157, 0.4);
            font-size: 2.5rem;
            animation: float 8s ease-in-out infinite;
        }

        .floating-element:nth-child(1) {
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .floating-element:nth-child(2) {
            top: 20%;
            right: 15%;
            animation-delay: 2s;
        }

        .floating-element:nth-child(3) {
            bottom: 25%;
            left: 20%;
            animation-delay: 4s;
        }

        .floating-element:nth-child(4) {
            bottom: 15%;
            right: 10%;
            animation-delay: 1s;
        }

        .floating-element:nth-child(5) {
            top: 60%;
            left: 5%;
            animation-delay: 3s;
        }

        .floating-element:nth-child(6) {
            top: 40%;
            right: 5%;
            animation-delay: 5s;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px) rotate(0deg);
                opacity: 0.4;
            }
            50% {
                transform: translateY(-30px) rotate(180deg);
                opacity: 0.8;
            }
        }

        /* Space Overlay Styles */
        .space-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0f0f23 50%, #000 100%);
            opacity: 0;
            visibility: hidden;
            transition: all 2s ease-in-out;
            z-index: 1000;
        }

        .space-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .stars-container {
            position: absolute;
            width: 100%;
            height: 100%;
            animation: rotate 120s linear infinite;
            transform-origin: center center;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
        }

        .star.small {
            width: 1px;
            height: 1px;
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
        }

        .star.medium {
            width: 2px;
            height: 2px;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.9);
        }

        .star.large {
            width: 3px;
            height: 3px;
            box-shadow: 0 0 12px rgba(255, 255, 255, 1);
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        /* Moving Background Objects */
        .space-objects {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }

        .space-object {
            position: absolute;
            border-radius: 50%;
            animation: drift 20s linear infinite;
        }

        .space-object.nebula1 {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(255, 107, 157, 0.3) 0%, transparent 70%);
            top: 20%;
            left: -120px;
            animation-duration: 25s;
        }

        .space-object.nebula2 {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.4) 0%, transparent 70%);
            top: 60%;
            left: -80px;
            animation-duration: 35s;
            animation-delay: 10s;
        }

        .space-object.comet {
            width: 4px;
            height: 4px;
            background: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 1), -20px 0 15px rgba(255, 255, 255, 0.3);
            top: 30%;
            left: -50px;
            animation-duration: 15s;
            animation-delay: 5s;
        }

        @keyframes drift {
            from { transform: translateX(0); }
            to { transform: translateX(calc(100vw + 200px)); }
        }

        /* Black Hole Effect */
        .black-hole-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            transition: all 4s ease-in-out;
            z-index: 1001;
        }

        .black-hole-container.expanding {
            width: 80vmin;
            height: 80vmin;
        }

        .black-hole {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: 
                radial-gradient(circle at center, 
                    transparent 25%, 
                    rgba(0, 0, 0, 0.1) 30%, 
                    rgba(0, 0, 0, 0.6) 45%, 
                    rgba(0, 0, 0, 0.9) 55%, 
                    black 65%);
            box-shadow: 
                inset 0 0 50px rgba(255, 107, 157, 0.3),
                inset 0 0 100px rgba(138, 43, 226, 0.2),
                0 0 100px rgba(0, 0, 0, 0.8);
            animation: blackHoleSwirl 8s linear infinite;
            position: relative;
            overflow: hidden;
        }

        .black-hole::before {
            content: '';
            position: absolute;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 107, 157, 0.15) 0%, transparent 60%);
            animation: accretionDisk 6s linear infinite reverse;
        }

        @keyframes blackHoleSwirl {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes counterRotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(-360deg); }
        }

        @keyframes accretionDisk {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Dynamic Sound Wave Visualization */
        .sound-wave-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1002;
        }

        .sound-wave {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 107, 157, 0.6);
            border-radius: 50%;
            opacity: 0;
            animation: soundWavePulse 2s ease-out infinite;
            transition: all 0.1s ease-out;
        }

        .sound-wave.active {
            opacity: 1;
        }

        .sound-wave.bouncing {
            animation: soundWaveBounce 0.8s ease-in-out infinite;
        }

        .sound-wave.fast-ring {
            animation: fastRingOut 0.5s ease-out infinite;
        }

        .sound-wave.slow-ring {
            animation: slowRingOut 3s ease-out infinite;
        }

        .sound-wave.bass-responsive {
            animation: bassWave 1.2s ease-in-out infinite;
        }

        .sound-wave.treble-responsive {
            animation: trebleWave 0.3s ease-in-out infinite;
        }

        .sound-wave:nth-child(1) {
            width: 50%;
            height: 50%;
            animation-delay: 0s;
            border-color: rgba(255, 107, 157, 0.8);
        }

        .sound-wave:nth-child(2) {
            width: 65%;
            height: 65%;
            animation-delay: 0.15s;
            border-color: rgba(255, 140, 180, 0.7);
        }

        .sound-wave:nth-child(3) {
            width: 80%;
            height: 80%;
            animation-delay: 0.3s;
            border-color: rgba(138, 43, 226, 0.6);
        }

        .sound-wave:nth-child(4) {
            width: 95%;
            height: 95%;
            animation-delay: 0.45s;
            border-color: rgba(74, 144, 226, 0.5);
        }

        /* Dynamic Ring Animations */
        @keyframes soundWavePulse {
            0% {
                transform: translate(-50%, -50%) scale(0.7);
                opacity: 0;
                border-width: 3px;
            }
            30% {
                opacity: 0.9;
                border-width: 2px;
            }
            70% {
                opacity: 0.6;
                border-width: 1px;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 0;
                border-width: 1px;
            }
        }

        @keyframes soundWaveBounce {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                border-width: 2px;
            }
            25% {
                transform: translate(-50%, -50%) scale(1.15) scaleY(0.9);
                border-width: 3px;
            }
            50% {
                transform: translate(-50%, -50%) scale(0.95) scaleY(1.1);
                border-width: 1px;
            }
            75% {
                transform: translate(-50%, -50%) scale(1.05) scaleY(0.95);
                border-width: 2px;
            }
        }

        @keyframes fastRingOut {
            0% {
                transform: translate(-50%, -50%) scale(0.3);
                opacity: 1;
                border-width: 4px;
                filter: blur(0px);
            }
            60% {
                opacity: 0.8;
                border-width: 2px;
                filter: blur(1px);
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
                border-width: 1px;
                filter: blur(2px);
            }
        }

        @keyframes slowRingOut {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
                border-width: 1px;
            }
            15% {
                opacity: 0.7;
                border-width: 3px;
            }
            50% {
                opacity: 0.5;
                border-width: 2px;
            }
            85% {
                opacity: 0.2;
                border-width: 1px;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.8);
                opacity: 0;
                border-width: 1px;
            }
        }

        @keyframes bassWave {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                border-radius: 50%;
                opacity: 0.6;
            }
            25% {
                transform: translate(-50%, -50%) scale(1.2) rotate(1deg);
                border-radius: 45%;
                opacity: 0.9;
            }
            50% {
                transform: translate(-50%, -50%) scale(0.9) rotate(0deg);
                border-radius: 55%;
                opacity: 0.7;
            }
            75% {
                transform: translate(-50%, -50%) scale(1.1) rotate(-1deg);
                border-radius: 47%;
                opacity: 0.8;
            }
        }

        @keyframes trebleWave {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.4;
                filter: brightness(1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
                opacity: 0.8;
                filter: brightness(1.3);
            }
        }

        /* Ripple Effect Rings */
        .ripple-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
        }

        .ripple-ring.active {
            animation: rippleEffect 2s ease-out forwards;
        }

        @keyframes rippleEffect {
            0% {
                width: 10px;
                height: 10px;
                opacity: 1;
                border-width: 2px;
            }
            50% {
                opacity: 0.6;
                border-width: 1px;
            }
            100% {
                width: 400px;
                height: 400px;
                opacity: 0;
                border-width: 0px;
            }
        }

        /* Audio Visualization Lines */
        .audio-visualizer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 280px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
            z-index: 1003;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .audio-visualizer.active {
            opacity: 1;
        }

        .audio-bar {
            width: 3px;
            background: linear-gradient(to top, #ff6b9d, #c44bd1, #4a90e2);
            border-radius: 2px;
            height: 10px;
            transform-origin: bottom;
            animation: audioBarDance 0.3s ease-in-out infinite alternate;
            box-shadow: 0 0 8px rgba(255, 107, 157, 0.5);
        }

        .audio-bar:nth-child(1) { animation-delay: 0s; }
        .audio-bar:nth-child(2) { animation-delay: 0.02s; }
        .audio-bar:nth-child(3) { animation-delay: 0.04s; }
        .audio-bar:nth-child(4) { animation-delay: 0.06s; }
        .audio-bar:nth-child(5) { animation-delay: 0.08s; }
        .audio-bar:nth-child(6) { animation-delay: 0.1s; }
        .audio-bar:nth-child(7) { animation-delay: 0.12s; }
        .audio-bar:nth-child(8) { animation-delay: 0.14s; }
        .audio-bar:nth-child(9) { animation-delay: 0.16s; }
        .audio-bar:nth-child(10) { animation-delay: 0.18s; }
        .audio-bar:nth-child(11) { animation-delay: 0.2s; }
        .audio-bar:nth-child(12) { animation-delay: 0.22s; }
        .audio-bar:nth-child(13) { animation-delay: 0.24s; }
        .audio-bar:nth-child(14) { animation-delay: 0.26s; }
        .audio-bar:nth-child(15) { animation-delay: 0.24s; }
        .audio-bar:nth-child(16) { animation-delay: 0.22s; }
        .audio-bar:nth-child(17) { animation-delay: 0.2s; }
        .audio-bar:nth-child(18) { animation-delay: 0.18s; }
        .audio-bar:nth-child(19) { animation-delay: 0.16s; }
        .audio-bar:nth-child(20) { animation-delay: 0.14s; }
        .audio-bar:nth-child(21) { animation-delay: 0.12s; }
        .audio-bar:nth-child(22) { animation-delay: 0.1s; }
        .audio-bar:nth-child(23) { animation-delay: 0.08s; }
        .audio-bar:nth-child(24) { animation-delay: 0.06s; }
        .audio-bar:nth-child(25) { animation-delay: 0.04s; }
        .audio-bar:nth-child(26) { animation-delay: 0.02s; }
        .audio-bar:nth-child(27) { animation-delay: 0s; }
        .audio-bar:nth-child(28) { animation-delay: 0.02s; }

        @keyframes audioBarDance {
            0% {
                transform: scaleY(0.3);
                opacity: 0.6;
            }
            100% {
                transform: scaleY(1);
                opacity: 1;
            }
        }

        /* Enhanced when speaking */
        .black-hole-container.speaking .black-hole {
            box-shadow: 
                inset 0 0 50px rgba(255, 107, 157, 0.8),
                inset 0 0 100px rgba(138, 43, 226, 0.6),
                0 0 150px rgba(255, 107, 157, 0.4),
                0 0 200px rgba(138, 43, 226, 0.3);
        }

        .black-hole-container.speaking .black-hole::before {
            background: radial-gradient(circle, rgba(255, 107, 157, 0.4) 0%, transparent 60%);
        }

        .chatgpt-iframe {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 90%;
            border: none;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(15px);
            opacity: 0;
            transition: opacity 2s ease-in-out;
            z-index: 1001;
            box-shadow: 
                inset 0 0 30px rgba(255, 107, 157, 0.1),
                inset 0 0 60px rgba(0, 0, 0, 0.9),
                0 0 30px rgba(0, 0, 0, 0.9);
            animation: counterRotate 8s linear infinite;
            overflow: hidden;
        }

        .chatgpt-iframe.show {
            opacity: 1;
        }

        .gpt-speaking-indicator {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 107, 157, 0.9) 0%, 
                rgba(138, 43, 226, 0.7) 50%, 
                rgba(74, 144, 226, 0.5) 100%);
            margin-bottom: 30px;
            animation: speakingPulse 2s ease-in-out infinite;
            box-shadow: 
                0 0 30px rgba(255, 107, 157, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            pointer-events: auto;
        }

        .gpt-speaking-indicator::before {
            content: 'ü§ñ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.2rem;
            animation: iconFloat 3s ease-in-out infinite;
        }

        .gpt-speaking-indicator.active {
            animation: speakingActive 0.5s ease-in-out infinite;
            box-shadow: 
                0 0 50px rgba(255, 107, 157, 1),
                0 0 100px rgba(138, 43, 226, 0.8),
                inset 0 0 30px rgba(255, 255, 255, 0.4);
        }

        @keyframes speakingPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.05);
                opacity: 1;
            }
        }

        @keyframes speakingActive {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 
                    0 0 50px rgba(255, 107, 157, 1),
                    0 0 100px rgba(138, 43, 226, 0.8);
            }
            25% { 
                transform: scale(1.3);
                box-shadow: 
                    0 0 80px rgba(255, 107, 157, 1),
                    0 0 150px rgba(138, 43, 226, 1);
            }
            75% { 
                transform: scale(0.9);
                box-shadow: 
                    0 0 40px rgba(255, 107, 157, 0.8),
                    0 0 80px rgba(138, 43, 226, 0.6);
            }
        }

        @keyframes iconFloat {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            50% { transform: translate(-50%, -50%) rotate(5deg) scale(1.05); }
        }

        .settings-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 1003;
            opacity: 0;
            animation: fadeInUp 1s ease-out 6.5s forwards;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(255, 255, 255, 0.3);
        }

        .settings-panel {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 1004;
        }

        .settings-panel.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .settings-panel h3 {
            color: #ff6b9d;
            margin-bottom: 15px;
            font-size: 1.1rem;
            text-align: center;
            border-bottom: 1px solid rgba(255, 107, 157, 0.3);
            padding-bottom: 10px;
        }

        .control-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-section h4 {
            color: #c44bd1;
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-align: center;
        }

        .test-button {
            background: linear-gradient(135deg, #4a90e2, #2c5aa0);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            margin: 3px;
            transition: all 0.3s ease;
            width: calc(50% - 6px);
            display: inline-block;
        }

        .test-button.full-width {
            width: calc(100% - 6px);
        }

        .test-button.danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .test-button.success {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .test-button.warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.4);
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e74c3c;
            margin-right: 5px;
            animation: pulse 2s infinite;
        }

        .status-indicator.active {
            background: #27ae60;
        }

        .status-indicator.warning {
            background: #f39c12;
        }

        .volume-control {
            width: 100%;
            margin: 10px 0;
        }

        .volume-slider {
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #ff6b9d;
            cursor: pointer;
        }

        .audio-route-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 8px;
            font-size: 0.8rem;
            color: #ccc;
            text-align: center;
            margin: 5px 0;
        }

        .chatgpt-link {
            background: linear-gradient(135deg, #ff6b9d, #c44bd1);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 0.9rem;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s ease;
            width: 100%;
            text-decoration: none;
            display: block;
            text-align: center;
        }

        .chatgpt-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 157, 0.4);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2rem;
            text-align: center;
            opacity: 1;
            transition: opacity 1s ease-in-out;
            z-index: 1004;
        }

        .loading-text.hidden {
            opacity: 0;
        }

        .fade-out {
            opacity: 0 !important;
            transform: scale(0.8) !important;
            visibility: hidden !important;
        }

        /* Floating Light Effects */
        .light-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }

        .light-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: floatLight 12s ease-in-out infinite;
        }

        @keyframes floatLight {
            0%, 100% {
                transform: translateY(100vh) translateX(0) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(10px) scale(1);
            }
            90% {
                opacity: 1;
                transform: translateY(-10vh) translateX(-10px) scale(1);
            }
            100% {
                transform: translateY(-20vh) translateX(0) scale(0);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                margin: 20px;
                padding: 40px 25px;
                max-width: 90vw;
            }
            
            .title {
                font-size: 2.8rem;
            }
            
            .subtitle {
                font-size: 1.1rem;
                margin-bottom: 25px;
            }

            .description {
                font-size: 1rem;
                margin-bottom: 40px;
            }
            
            .launch-button {
                padding: 20px 40px;
                font-size: 1.2rem;
            }

            .feature-grid {
                grid-template-columns: 1fr;
            }

            .black-hole-container.expanding {
                width: 90vmin;
                height: 90vmin;
            }

            .chatgpt-iframe {
                width: 85%;
                height: 85%;
            }

            .audio-visualizer {
                width: 200px;
                height: 100px;
            }

            .audio-bar {
                width: 2px;
            }

            .settings-button {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
                bottom: 15px;
                right: 15px;
            }

            .settings-panel {
                width: 320px;
                bottom: 70px;
                right: 15px;
                padding: 15px;
                max-height: 75vh;
            }

            .control-section {
                margin-bottom: 15px;
                padding: 12px;
            }

            .test-button {
                font-size: 0.75rem;
                padding: 6px 10px;
            }

            .voice-control-overlay {
                width: 280px;
                bottom: 80px;
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .title {
                font-size: 2.4rem;
            }
            
            .launch-button {
                padding: 18px 35px;
                font-size: 1.1rem;
            }

            .chatgpt-iframe {
                width: 90%;
                height: 90%;
            }

            .audio-visualizer {
                width: 160px;
                height: 80px;
                gap: 1px;
            }

            .audio-bar {
                width: 2px;
            }

            .settings-button {
                width: 40px;
                height: 40px;
                font-size: 1rem;
                bottom: 10px;
                right: 10px;
            }

            .settings-panel {
                width: 300px;
                bottom: 60px;
                right: 10px;
                padding: 12px;
                max-height: 70vh;
            }

            .control-section {
                margin-bottom: 12px;
                padding: 10px;
            }

            .control-section h4 {
                font-size: 0.8rem;
            }

            .test-button {
                font-size: 0.7rem;
                padding: 5px 8px;
            }

            .voice-control-overlay {
                width: 260px;
                bottom: 70px;
                padding: 12px;
            }

            .chatgpt-control-panel {
                width: 320px;
                top: 10px;
                padding: 10px;
            }

            .volume-slider {
                height: 4px;
            }

            .audio-route-display {
                font-size: 0.7rem;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="aurora-bg"></div>
    
    <div class="floating-elements">
        <div class="floating-element">üé§</div>
        <div class="floating-element">üíï</div>
        <div class="floating-element">ü§ñ</div>
        <div class="floating-element">‚ú®</div>
        <div class="floating-element">üåü</div>
        <div class="floating-element">üí´</div>
    </div>
    
    <div class="main-content">
        <h1 class="title">AI Voice Assistant</h1>
        
        <p class="subtitle">Simple iPhone mic & speaker control for ChatGPT</p>
        
        <p class="description">
            Direct iPhone microphone and speaker control for ChatGPT! Simple, straightforward controls to force your iPhone's mic and speaker to work with the ChatGPT conversation. Beautiful dynamic audio visualization responds with bouncing waves, fast rings, and ripple effects.
        </p>
        
        <a href="#" onclick="launchAssistant(); return false;" class="launch-button">
            <span class="button-icon">üöÄ</span>
            Launch AI Assistant
        </a>
        
        <div class="features">
            <h3>‚ú® Key Features</h3>
            <ul class="feature-grid">
                <li class="feature-item">Direct iPhone microphone activation with one-click setup</li>
                <li class="feature-item">Forced iPhone speaker output for clear ChatGPT audio</li>
                <li class="feature-item">28 intelligent audio bars with dynamic bounce and wave patterns</li>
                <li class="feature-item">Simple voice-to-text injection directly into ChatGPT</li>
                <li class="feature-item">iPhone speech recognition with continuous listening</li>
                <li class="feature-item">Volume control and audio testing for iPhone speakers</li>
                <li class="feature-item">Smart wave detection: fast rings, slow rings, bouncing effects</li>
                <li class="feature-item">Streamlined controls focused on iPhone compatibility</li>
            </ul>
        </div>
    </div>

    <!-- Space Overlay -->
    <div class="space-overlay" id="spaceOverlay">
        <div class="stars-container" id="starsContainer">
            <!-- Stars will be generated by JavaScript -->
        </div>
        
        <div class="space-objects">
            <div class="space-object nebula1"></div>
            <div class="space-object nebula2"></div>
            <div class="space-object comet"></div>
        </div>

        <div class="light-particles" id="lightParticles">
            <!-- Light particles will be generated by JavaScript -->
        </div>
        
        <div class="loading-text" id="loadingText">
            üåå Opening cosmic portal...<br>
            <small style="opacity: 0.7;">Initializing sound wave detection...</small>
        </div>
        
        <div class="black-hole-container" id="blackHoleContainer">
            <div class="black-hole">
                <!-- Sound Wave Visualization -->
                <div class="sound-wave-container" id="soundWaveContainer">
                    <div class="sound-wave"></div>
                    <div class="sound-wave"></div>
                    <div class="sound-wave"></div>
                    <div class="sound-wave"></div>
                </div>
                
                <!-- Audio Visualizer Bars -->
                <div class="audio-visualizer" id="audioVisualizer">
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                </div>
                
                <!-- ChatGPT iframe -->
                <iframe class="chatgpt-iframe" id="chatgptFrame" src=""></iframe>
            </div>
        </div>

        <button class="settings-button" id="settingsBtn" onclick="toggleSettings()">
            ‚öôÔ∏è
        </button>

        <div class="settings-panel" id="settingsPanel">
            <h3>üì± iPhone Mic & Speaker Control</h3>
            
            <!-- Sound Wave Controls -->
            <div class="control-section">
                <h4>üåä Sound Wave Visualization</h4>
                <button class="test-button" onclick="testSoundWaves()">üåä Test 28 Bars</button>
                <button class="test-button" onclick="toggleSoundDetection()">üé§ Toggle Detection</button>
            </div>

            <!-- iPhone Microphone Control -->
            <div class="control-section">
                <h4>üé§ iPhone Microphone</h4>
                <div class="voice-status-display">
                    <span>Microphone:</span>
                    <span><span class="status-indicator" id="micStatus"></span><span id="micStatusText">Not Active</span></span>
                </div>
                <button class="test-button success full-width" onclick="activateIPhoneMic()">üé§ Activate iPhone Mic</button>
                <div class="voice-status-display">
                    <span>Speech Recognition:</span>
                    <span><span class="status-indicator" id="speechStatus"></span><span id="speechStatusText">Inactive</span></span>
                </div>
            </div>

            <!-- iPhone Speaker Control -->
            <div class="control-section">
                <h4>üîä iPhone Speaker</h4>
                <div class="voice-status-display">
                    <span>Speaker Output:</span>
                    <span><span class="status-indicator" id="speakerStatus"></span><span id="speakerStatusText">Default</span></span>
                </div>
                <button class="test-button success full-width" onclick="forceIPhoneSpeaker()">üîä Force iPhone Speaker</button>
                <div class="volume-control">
                    <label style="color: #ccc; font-size: 0.8rem;">Volume:</label>
                    <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="100" onchange="setIPhoneVolume(this.value)">
                </div>
            </div>

            <!-- ChatGPT Voice Control -->
            <div class="control-section">
                <h4>ü§ñ ChatGPT Voice</h4>
                <div class="voice-status-display">
                    <span>ChatGPT Status:</span>
                    <span><span class="status-indicator" id="chatgptStatus"></span><span id="chatgptStatusText">Loading...</span></span>
                </div>
                <button class="test-button warning full-width" onclick="activateChatGPTVoiceSimple()">üé§ Activate ChatGPT Voice</button>
                <button class="test-button" onclick="refreshChatGPT()">üîÑ Refresh ChatGPT</button>
                <button class="test-button" onclick="sendTestMessage()">üìù Send Test Message</button>
            </div>

            <!-- Quick Setup -->
            <div class="control-section">
                <h4>‚ö° Quick Setup</h4>
                <button class="test-button success full-width" onclick="setupIPhoneAudioComplete()">üì± Setup iPhone Audio</button>
                <button class="test-button warning full-width" onclick="testIPhoneAudio()">üîä Test iPhone Audio</button>
                <button class="test-button" onclick="checkAudioStatus()">üìä Check Status</button>
                <button class="test-button danger" onclick="resetAudioSystems()">üîÑ Reset Audio</button>
            </div>

            <!-- Direct Link -->
            <div class="control-section">
                <h4>üîó Direct Access</h4>
                <a href="https://chatgpt.com/c/685f5529-0888-800c-b96a-008419428418" 
                   target="_blank" 
                   class="test-button full-width"
                   style="text-decoration: none; text-align: center; display: block;">
                    üöÄ Open ChatGPT in New Tab
                </a>
            </div>
        </div>
    </div>

    <script>
        // Global audio and visualization variables
        window.audioContext = null;
        window.audioAnalyser = null;
        window.audioData = null;
        window.soundDetectionActive = false;
        window.visualizationActive = false;
        window.animationFrameId = null;

        function launchAssistant() {
            // Fade out main content
            const mainContent = document.querySelector('.main-content');
            const auroraBackground = document.querySelector('.aurora-bg');
            const floatingElements = document.querySelector('.floating-elements');
            
            mainContent.classList.add('fade-out');
            auroraBackground.classList.add('fade-out');
            floatingElements.classList.add('fade-out');
            
            // Show space overlay after a delay
            setTimeout(() => {
                const spaceOverlay = document.getElementById('spaceOverlay');
                spaceOverlay.classList.add('active');
                
                // Generate stars and light particles
                generateStars();
                generateLightParticles();
                
                // Start black hole animation
                setTimeout(() => {
                    openBlackHole();
                }, 2000);
            }, 500);
        }

        function generateStars() {
            const starsContainer = document.getElementById('starsContainer');
            const starCount = 150;
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                
                // Random star size
                const size = Math.random();
                if (size < 0.6) {
                    star.classList.add('small');
                } else if (size < 0.9) {
                    star.classList.add('medium');
                } else {
                    star.classList.add('large');
                }
                
                // Random position
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                
                // Random animation delay
                star.style.animationDelay = Math.random() * 3 + 's';
                
                starsContainer.appendChild(star);
            }
        }

        function generateLightParticles() {
            const lightParticles = document.getElementById('lightParticles');
            const particleCount = 20;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.classList.add('light-particle');
                
                // Random horizontal position
                particle.style.left = Math.random() * 100 + '%';
                
                // Random animation delay and duration
                particle.style.animationDelay = Math.random() * 12 + 's';
                particle.style.animationDuration = (8 + Math.random() * 8) + 's';
                
                lightParticles.appendChild(particle);
            }
        }

        function openBlackHole() {
            const loadingText = document.getElementById('loadingText');
            const blackHoleContainer = document.getElementById('blackHoleContainer');
            
            // Update loading text
            loadingText.innerHTML = 'üï≥Ô∏è Black hole opening...<br><small style="opacity: 0.7;">Preparing sound wave detection...</small>';
            
            // Expand black hole
            blackHoleContainer.classList.add('expanding');
            
            // Initialize audio system
            initializeAudioSystem();
            
            // Load ChatGPT after black hole opens
            setTimeout(() => {
                loadChatGPT();
            }, 4000);
        }

        function initializeAudioSystem() {
            try {
                // Create audio context for sound analysis
                window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create analyser node for frequency analysis
                window.audioAnalyser = window.audioContext.createAnalyser();
                window.audioAnalyser.fftSize = 256;
                window.audioAnalyser.smoothingTimeConstant = 0.8;
                
                // Create data array for frequency data
                const bufferLength = window.audioAnalyser.frequencyBinCount;
                window.audioData = new Uint8Array(bufferLength);
                
                console.log('Audio system initialized for sound wave detection');
                
                // Start monitoring ambient audio
                startAmbientAudioMonitoring();
                
            } catch (error) {
                console.log('Audio system initialization error:', error);
            }
        }

        function startAmbientAudioMonitoring() {
            // Try to get user media for ambient sound detection
            navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false,
                    sampleRate: 44100
                }
            })
            .then(function(stream) {
                console.log('Microphone access granted for sound detection');
                
                // Connect microphone to analyser
                const source = window.audioContext.createMediaStreamSource(stream);
                source.connect(window.audioAnalyser);
                
                // Enable sound detection
                window.soundDetectionActive = true;
                
                // Start visual analysis
                startSoundVisualization();
                
            })
            .catch(function(error) {
                console.log('Microphone access denied, using simulated detection:', error);
                
                // Use simulated audio detection
                startSimulatedSoundDetection();
            });
        }

        function startSoundVisualization() {
            if (!window.visualizationActive) {
                window.visualizationActive = true;
                animateSoundWaves();
            }
        }

        function animateSoundWaves() {
            if (!window.visualizationActive) return;
            
            // Analyze audio data with enhanced frequency analysis
            if (window.audioAnalyser && window.audioData && window.soundDetectionActive) {
                window.audioAnalyser.getByteFrequencyData(window.audioData);
                
                // Advanced frequency analysis
                const freqAnalysis = analyzeFrequencySpectrum(window.audioData);
                
                // Update visualizations with intelligent responses
                updateDynamicSoundWaves(freqAnalysis);
                updateAudioBars(window.audioData);
                
                // Generate dynamic effects based on audio characteristics
                generateDynamicEffects(freqAnalysis);
                
                // Update black hole responsiveness
                updateBlackHoleEffects(freqAnalysis);
                
            } else {
                // Simulate realistic audio patterns for demonstration
                const simulatedAnalysis = generateSimulatedAudioAnalysis();
                updateDynamicSoundWaves(simulatedAnalysis);
                updateAudioBars(window.audioData || new Uint8Array(256));
            }
            
            // Continue animation loop
            window.animationFrameId = requestAnimationFrame(animateSoundWaves);
        }

        function analyzeFrequencySpectrum(audioData) {
            const dataLength = audioData.length;
            
            // Analyze different frequency ranges
            const bassRange = audioData.slice(0, Math.floor(dataLength * 0.1)); // 0-10%
            const midRange = audioData.slice(Math.floor(dataLength * 0.1), Math.floor(dataLength * 0.4)); // 10-40%
            const trebleRange = audioData.slice(Math.floor(dataLength * 0.4), dataLength); // 40-100%
            
            // Calculate averages and peaks
            const bassAvg = bassRange.reduce((a, b) => a + b, 0) / bassRange.length;
            const midAvg = midRange.reduce((a, b) => a + b, 0) / midRange.length;
            const trebleAvg = trebleRange.reduce((a, b) => a + b, 0) / trebleRange.length;
            
            const bassPeak = Math.max(...bassRange);
            const midPeak = Math.max(...midRange);
            const treblePeak = Math.max(...trebleRange);
            
            // Overall audio characteristics
            const totalAvg = audioData.reduce((a, b) => a + b, 0) / dataLength;
            const totalPeak = Math.max(...audioData);
            
            // Detect audio patterns
            const isRhythmic = detectRhythmicPattern(audioData);
            const isSpeech = detectSpeechPattern(bassAvg, midAvg, trebleAvg);
            const isMusic = detectMusicPattern(bassAvg, midAvg, trebleAvg);
            
            return {
                bass: { avg: bassAvg, peak: bassPeak },
                mid: { avg: midAvg, peak: midPeak },
                treble: { avg: trebleAvg, peak: treblePeak },
                total: { avg: totalAvg, peak: totalPeak },
                patterns: { isRhythmic, isSpeech, isMusic },
                intensity: calculateIntensity(totalAvg, totalPeak)
            };
        }

        function updateDynamicSoundWaves(analysis) {
            const soundWaves = document.querySelectorAll('.sound-wave');
            const blackHoleContainer = document.getElementById('blackHoleContainer');
            
            // Base activation threshold
            const activationThreshold = 8;
            
            if (analysis.total.avg > activationThreshold) {
                // Activate waves with different behaviors based on audio type
                soundWaves.forEach((wave, index) => {
                    wave.classList.add('active');
                    
                    // Remove previous animation classes
                    wave.classList.remove('bouncing', 'fast-ring', 'slow-ring', 'bass-responsive', 'treble-responsive');
                    
                    // Apply dynamic behaviors based on frequency analysis
                    if (analysis.patterns.isRhythmic && analysis.bass.avg > 20) {
                        // Bouncing effect for rhythmic bass
                        wave.classList.add('bouncing');
                        wave.style.borderColor = `rgba(255, ${107 + analysis.bass.avg}, 157, ${0.3 + analysis.bass.avg / 255})`;
                    } else if (analysis.treble.peak > 100) {
                        // Fast rings for high treble activity
                        wave.classList.add('fast-ring', 'treble-responsive');
                        wave.style.borderColor = `rgba(${74 + analysis.treble.avg}, 144, 226, ${0.4 + analysis.treble.avg / 255})`;
                    } else if (analysis.bass.peak > 80) {
                        // Slow, powerful waves for strong bass
                        wave.classList.add('slow-ring', 'bass-responsive');
                        wave.style.borderColor = `rgba(255, ${107 + analysis.bass.avg * 0.5}, ${157 + analysis.bass.avg * 0.3}, 0.7)`;
                    } else if (analysis.patterns.isSpeech) {
                        // Gentle pulsing for speech
                        wave.style.animationDuration = '1.5s';
                        wave.style.borderColor = `rgba(138, ${43 + analysis.mid.avg}, 226, ${0.5 + analysis.mid.avg / 255})`;
                    } else {
                        // Default responsive behavior
                        wave.style.animationDuration = `${2 - (analysis.intensity * 1.5)}s`;
                    }
                    
                    // Dynamic sizing based on frequency ranges
                    const sizeMultiplier = 1 + (analysis.total.avg / 255) * 0.4;
                    wave.style.transform = `translate(-50%, -50%) scale(${sizeMultiplier})`;
                    
                    // Staggered delays for wave propagation effect
                    wave.style.animationDelay = `${index * 0.1 + (analysis.intensity * 0.05)}s`;
                });
                
                blackHoleContainer.classList.add('speaking');
                
                // Generate ripple effects for audio spikes
                if (analysis.total.peak > 150) {
                    generateRippleEffect(analysis.total.peak);
                }
                
            } else {
                // Deactivate waves gradually
                soundWaves.forEach(wave => {
                    wave.classList.remove('active', 'bouncing', 'fast-ring', 'slow-ring', 'bass-responsive', 'treble-responsive');
                });
                blackHoleContainer.classList.remove('speaking');
            }
        }

        function generateDynamicEffects(analysis) {
            const soundWaveContainer = document.getElementById('soundWaveContainer');
            
            // Create additional dynamic waves based on audio characteristics
            if (analysis.patterns.isRhythmic && analysis.bass.avg > 30) {
                createDynamicWave('bass-blast', {
                    size: 120 + analysis.bass.avg,
                    color: `rgba(255, ${80 + analysis.bass.avg}, 100, 0.6)`,
                    duration: 800,
                    pattern: 'bounce'
                });
            }
            
            if (analysis.treble.peak > 120) {
                createDynamicWave('treble-burst', {
                    size: 60 + analysis.treble.avg,
                    color: `rgba(100, ${150 + analysis.treble.avg * 0.4}, 255, 0.7)`,
                    duration: 300,
                    pattern: 'fast-ring'
                });
            }
            
            if (analysis.patterns.isMusic && analysis.mid.avg > 25) {
                createDynamicWave('music-flow', {
                    size: 90 + analysis.mid.avg,
                    color: `rgba(${120 + analysis.mid.avg}, 100, 220, 0.5)`,
                    duration: 1500,
                    pattern: 'flow'
                });
            }
        }

        function createDynamicWave(type, properties) {
            const container = document.getElementById('soundWaveContainer');
            
            // Limit number of dynamic waves
            const existingWaves = container.querySelectorAll(`.dynamic-wave-${type}`);
            if (existingWaves.length > 3) return;
            
            const dynamicWave = document.createElement('div');
            dynamicWave.className = `sound-wave dynamic-wave-${type} active`;
            dynamicWave.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: ${properties.size}%;
                height: ${properties.size}%;
                border: 2px solid ${properties.color};
                border-radius: 50%;
                opacity: 1;
                animation: ${getDynamicAnimation(properties.pattern)} ${properties.duration}ms ease-out;
                pointer-events: none;
            `;
            
            container.appendChild(dynamicWave);
            
            // Remove after animation
            setTimeout(() => {
                if (dynamicWave.parentElement) {
                    dynamicWave.remove();
                }
            }, properties.duration);
        }

        function getDynamicAnimation(pattern) {
            switch (pattern) {
                case 'bounce': return 'soundWaveBounce';
                case 'fast-ring': return 'fastRingOut';
                case 'flow': return 'slowRingOut';
                default: return 'soundWavePulse';
            }
        }

        function generateRippleEffect(intensity) {
            const blackHole = document.querySelector('.black-hole');
            
            // Create ripple ring
            const ripple = document.createElement('div');
            ripple.className = 'ripple-ring active';
            
            // Dynamic ripple properties based on intensity
            const speed = Math.max(500, 2000 - intensity * 8);
            const opacity = Math.min(1, intensity / 255);
            
            ripple.style.animationDuration = `${speed}ms`;
            ripple.style.opacity = opacity;
            
            blackHole.appendChild(ripple);
            
            // Remove after animation
            setTimeout(() => {
                if (ripple.parentElement) {
                    ripple.remove();
                }
            }, speed);
        }

        function updateBlackHoleEffects(analysis) {
            const blackHole = document.querySelector('.black-hole');
            
            // Dynamic black hole effects based on audio
            if (analysis.total.avg > 20) {
                const intensity = analysis.intensity;
                const hue = analysis.bass.avg > analysis.treble.avg ? 320 : 240; // Purple for bass, blue for treble
                
                blackHole.style.boxShadow = `
                    inset 0 0 ${50 + intensity * 30}px hsla(${hue}, 70%, 60%, ${0.3 + intensity * 0.5}),
                    inset 0 0 ${100 + intensity * 50}px hsla(${hue}, 50%, 40%, ${0.2 + intensity * 0.4}),
                    0 0 ${100 + intensity * 100}px hsla(${hue}, 60%, 50%, ${0.1 + intensity * 0.3})
                `;
                
                // Rhythmic pulsing for the accretion disk
                if (analysis.patterns.isRhythmic) {
                    blackHole.style.animationDuration = `${4 - intensity * 2}s`;
                }
            } else {
                // Reset to default
                blackHole.style.boxShadow = '';
                blackHole.style.animationDuration = '8s';
            }
        }

        // Pattern detection functions
        function detectRhythmicPattern(audioData) {
            // Simple rhythm detection based on consistent peaks
            let peakCount = 0;
            const threshold = 60;
            
            for (let i = 0; i < audioData.length; i++) {
                if (audioData[i] > threshold) {
                    peakCount++;
                }
            }
            
            return peakCount > audioData.length * 0.1 && peakCount < audioData.length * 0.3;
        }

        function detectSpeechPattern(bass, mid, treble) {
            // Speech typically has strong mid-range with moderate bass and treble
            return mid > bass && mid > treble && mid > 15 && treble > 10;
        }

        function detectMusicPattern(bass, mid, treble) {
            // Music typically has a more balanced frequency distribution
            const total = bass + mid + treble;
            return total > 40 && bass > 10 && treble > 10;
        }

        function calculateIntensity(avg, peak) {
            // Normalized intensity from 0 to 1
            return Math.min(1, (avg * 0.7 + peak * 0.3) / 255);
        }

        function generateSimulatedAudioAnalysis() {
            // Enhanced simulation for demonstration
            const time = Date.now() / 1000;
            const bassWave = Math.sin(time * 2) * 30 + 30;
            const midWave = Math.sin(time * 3) * 25 + 25;
            const trebleWave = Math.sin(time * 5) * 20 + 15;
            
            return {
                bass: { avg: bassWave, peak: bassWave * 1.5 },
                mid: { avg: midWave, peak: midWave * 1.3 },
                treble: { avg: trebleWave, peak: trebleWave * 1.2 },
                total: { avg: (bassWave + midWave + trebleWave) / 3, peak: Math.max(bassWave, midWave, trebleWave) },
                patterns: { 
                    isRhythmic: Math.sin(time) > 0.5,
                    isSpeech: Math.sin(time * 0.7) > 0.3,
                    isMusic: Math.sin(time * 1.2) > 0
                },
                intensity: (Math.sin(time * 1.5) + 1) / 2
            };
        }

        function updateSoundWaveVisuals(audioLevel) {
            const soundWaves = document.querySelectorAll('.sound-wave');
            const blackHoleContainer = document.getElementById('blackHoleContainer');
            
            // Activate sound waves based on audio level
            if (audioLevel > 10) {
                soundWaves.forEach(wave => wave.classList.add('active'));
                blackHoleContainer.classList.add('speaking');
                
                // Dynamic wave sizing based on audio level
                soundWaves.forEach((wave, index) => {
                    const scale = 1 + (audioLevel / 255) * 0.5;
                    const delay = index * 0.1;
                    wave.style.animationDelay = delay + 's';
                    wave.style.transform = `translate(-50%, -50%) scale(${scale})`;
                });
            } else {
                soundWaves.forEach(wave => wave.classList.remove('active'));
                blackHoleContainer.classList.remove('speaking');
            }
        }

        function updateAudioBars(frequencyData) {
            const audioBars = document.querySelectorAll('.audio-bar');
            const audioVisualizer = document.getElementById('audioVisualizer');
            
            // Show visualizer if there's audio activity
            let hasActivity = false;
            for (let i = 0; i < frequencyData.length; i++) {
                if (frequencyData[i] > 5) {
                    hasActivity = true;
                    break;
                }
            }
            
            if (hasActivity) {
                audioVisualizer.classList.add('active');
                
                // Update each audio bar based on frequency data with better distribution
                audioBars.forEach((bar, index) => {
                    // Map 28 bars across the frequency spectrum more evenly
                    const dataIndex = Math.floor(index * frequencyData.length / audioBars.length);
                    let height = (frequencyData[dataIndex] / 255) * 120;
                    
                    // Add some random variation for more dynamic effect
                    height = height * (0.8 + Math.random() * 0.4);
                    
                    // Create a more musical distribution (emphasize lower frequencies)
                    if (index < 8) {
                        height = height * 1.2; // Boost bass frequencies
                    } else if (index > 20) {
                        height = height * 0.8; // Reduce high frequencies slightly
                    }
                    
                    bar.style.height = Math.max(8, height) + 'px';
                    bar.style.animationDuration = (0.1 + Math.random() * 0.2) + 's';
                    
                    // Add color variation based on frequency range
                    if (index < 7) {
                        bar.style.background = 'linear-gradient(to top, #ff6b9d, #ff8fab, #ffb3c6)'; // Pink/red for bass
                    } else if (index < 14) {
                        bar.style.background = 'linear-gradient(to top, #c44bd1, #d666e0, #e888ee)'; // Purple for mid
                    } else if (index < 21) {
                        bar.style.background = 'linear-gradient(to top, #4a90e2, #6ba3e8, #8cb6ee)'; // Blue for high-mid
                    } else {
                        bar.style.background = 'linear-gradient(to top, #74c0fc, #92d3ff, #b0e6ff)'; // Light blue for treble
                    }
                });
            } else {
                audioVisualizer.classList.remove('active');
            }
        }

        function activateSpeechVisualization() {
            const blackHoleContainer = document.getElementById('blackHoleContainer');
            const soundWaveContainer = document.getElementById('soundWaveContainer');
            
            // Enhanced visual effects during speech
            blackHoleContainer.classList.add('speaking');
            
            // Additional wave effects
            if (!soundWaveContainer.querySelector('.extra-wave')) {
                for (let i = 0; i < 3; i++) {
                    const extraWave = document.createElement('div');
                    extraWave.className = 'sound-wave extra-wave active';
                    extraWave.style.width = (100 + i * 20) + '%';
                    extraWave.style.height = (100 + i * 20) + '%';
                    extraWave.style.animationDelay = (1.2 + i * 0.2) + 's';
                    extraWave.style.borderColor = `rgba(${255 - i * 50}, ${107 + i * 30}, ${157 + i * 20}, ${0.3 - i * 0.1})`;
                    soundWaveContainer.appendChild(extraWave);
                }
            }
        }

        function deactivateSpeechVisualization() {
            const blackHoleContainer = document.getElementById('blackHoleContainer');
            const extraWaves = document.querySelectorAll('.extra-wave');
            
            // Remove enhanced effects when speech stops
            setTimeout(() => {
                blackHoleContainer.classList.remove('speaking');
                extraWaves.forEach(wave => wave.remove());
            }, 500);
        }

        function startSimulatedSoundDetection() {
            // Simulated audio detection for testing purposes
            console.log('Using simulated sound detection');
            
            window.soundDetectionActive = true;
            startSoundVisualization();
            
            // Simulate random audio activity for demonstration
            setInterval(() => {
                if (Math.random() > 0.8) {
                    // Simulate speech activity
                    simulateAudioActivity(50 + Math.random() * 100);
                } else {
                    // Simulate quiet
                    simulateAudioActivity(5 + Math.random() * 10);
                }
            }, 500);
        }

        function simulateAudioActivity(level) {
            // Simulate audio data for visualization
            if (window.audioData) {
                for (let i = 0; i < window.audioData.length; i++) {
                    window.audioData[i] = level + Math.random() * 50 - 25;
                    window.audioData[i] = Math.max(0, Math.min(255, window.audioData[i]));
                }
            }
        }

        // Global variables for portal control
        window.portalAudioContext = null;
        window.portalSpeakerOutput = null;
        window.chatgptControlActive = false;
        window.voiceSystemActive = false;
        window.microphoneBypassActive = false;
        window.speakerForceActive = false;

        function loadChatGPT() {
            const loadingText = document.getElementById('loadingText');
            const chatgptFrame = document.getElementById('chatgptFrame');
            
            // Direct load ChatGPT conversation
            chatgptFrame.src = 'https://chatgpt.com/c/685f5529-0888-800c-b96a-008419428418';
            
            // Update loading text
            loadingText.innerHTML = 'üöÄ ChatGPT Loading...<br><small style="opacity: 0.7;">Setting up iPhone mic & speaker...</small>';
            
            // Initialize simple control systems
            initializeSimpleAudioControl();
            
            // Show ChatGPT interface
            setTimeout(() => {
                chatgptFrame.classList.add('show');
                loadingText.classList.add('hidden');
                
                // Force iPhone mic and speaker
                forceIPhoneMicAndSpeaker();
                
                // Simple ChatGPT voice activation
                activateChatGPTVoiceSimple();
                
                // Start basic monitoring
                startSimpleMonitoring();
                
            }, 2000);
        }

        function initializeSimpleAudioControl() {
            console.log('üéµ Setting up iPhone mic & speaker control...');
            
            // Simple audio context for iPhone
            try {
                window.portalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Force audio context to start
                window.portalAudioContext.resume().then(() => {
                    console.log('‚úÖ iPhone audio context ready');
                    updateStatusIndicator('speakerStatus', 'success', 'iPhone Speaker Ready');
                });
                
                // Create speaker output
                window.speakerOutput = window.portalAudioContext.createGain();
                window.speakerOutput.connect(window.portalAudioContext.destination);
                window.speakerOutput.gain.value = 1.0; // Max volume
                
            } catch (error) {
                console.log('‚ùå iPhone audio setup error:', error);
                updateStatusIndicator('speakerStatus', 'warning', 'Audio Setup Failed');
            }
            
            // Set initial status
            updateStatusIndicator('chatgptStatus', 'warning', 'Loading...');
            updateStatusIndicator('micStatus', 'warning', 'Preparing...');
            updateStatusIndicator('speakerStatus', 'warning', 'Preparing...');
        }

        function forceIPhoneMicAndSpeaker() {
            console.log('üì± Forcing iPhone microphone and speaker...');
            
            // Get iPhone microphone access
            navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            })
            .then(function(stream) {
                console.log('‚úÖ iPhone microphone activated');
                window.micStream = stream;
                
                // Connect mic to audio system
                if (window.portalAudioContext) {
                    const micSource = window.portalAudioContext.createMediaStreamSource(stream);
                    if (window.audioAnalyser) {
                        micSource.connect(window.audioAnalyser);
                    }
                }
                
                // Start speech recognition for voice input
                startIPhoneSpeechRecognition();
                
                updateStatusIndicator('micStatus', 'success', 'iPhone Mic Active');
                showNotification('üé§ iPhone Mic Ready', 'iPhone microphone is now active and ready for voice input.', 'success');
                
            })
            .catch(function(error) {
                console.log('‚ö†Ô∏è iPhone microphone access denied:', error);
                updateStatusIndicator('micStatus', 'warning', 'Mic Access Denied');
                showNotification('üé§ Mic Permission', 'Please allow microphone access for voice features.', 'warning');
            });
            
            // Force iPhone speaker output
            forceIPhoneSpeaker();
        }

        function forceIPhoneSpeaker() {
            console.log('üîä Forcing iPhone speaker output...');
            
            try {
                // Ensure audio context is running for speaker output
                if (window.portalAudioContext) {
                    window.portalAudioContext.resume();
                }
                
                // Override all audio to use iPhone speaker
                if ('speechSynthesis' in window) {
                    const originalSpeak = speechSynthesis.speak;
                    speechSynthesis.speak = function(utterance) {
                        utterance.volume = 1.0; // Max volume
                        utterance.rate = 0.9;   // Clear speech rate
                        console.log('üîä Forcing speech to iPhone speaker');
                        return originalSpeak.call(this, utterance);
                    };
                }
                
                // Force all audio elements to max volume
                setInterval(() => {
                    const audioElements = document.querySelectorAll('audio, video');
                    audioElements.forEach(audio => {
                        audio.volume = 1.0;
                        audio.muted = false;
                    });
                }, 1000);
                
                // Test iPhone speaker with notification sound
                playIPhoneTestSound();
                
                updateStatusIndicator('speakerStatus', 'success', 'iPhone Speaker Forced');
                showNotification('üîä iPhone Speaker Ready', 'Audio output forced to iPhone speaker at maximum volume.', 'success');
                
            } catch (error) {
                console.log('‚ùå iPhone speaker forcing error:', error);
                updateStatusIndicator('speakerStatus', 'warning', 'Speaker Force Failed');
            }
        }

        function playIPhoneTestSound() {
            if (window.portalAudioContext) {
                const oscillator = window.portalAudioContext.createOscillator();
                const gainNode = window.portalAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(window.portalAudioContext.destination);
                
                oscillator.frequency.setValueAtTime(880, window.portalAudioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, window.portalAudioContext.currentTime);
                
                oscillator.start();
                oscillator.stop(window.portalAudioContext.currentTime + 0.3);
                
                console.log('üîä iPhone speaker test sound played');
            }
        }

        function startIPhoneSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                window.recognition = new SpeechRecognition();
                
                window.recognition.continuous = true;
                window.recognition.interimResults = false;
                window.recognition.lang = 'en-US';
                
                window.recognition.onstart = function() {
                    console.log('üé§ iPhone speech recognition started');
                    updateStatusIndicator('speechStatus', 'success', 'Listening');
                };
                
                window.recognition.onresult = function(event) {
                    const lastResult = event.results[event.results.length - 1];
                    if (lastResult.isFinal) {
                        const transcript = lastResult[0].transcript;
                        console.log('üé§ Voice input:', transcript);
                        
                        // Send directly to ChatGPT
                        sendVoiceInputToChatGPT(transcript);
                        
                        showNotification('üé§ Voice ‚Üí ChatGPT', `"${transcript.substring(0, 30)}..."`, 'info');
                    }
                };
                
                window.recognition.onerror = function(event) {
                    console.log('üîÑ Speech recognition error, restarting:', event.error);
                    setTimeout(() => {
                        if (window.recognition) {
                            window.recognition.start();
                        }
                    }, 1000);
                };
                
                window.recognition.onend = function() {
                    console.log('üîÑ Speech recognition ended, restarting...');
                    setTimeout(() => {
                        if (window.recognition) {
                            window.recognition.start();
                        }
                    }, 100);
                };
                
                window.recognition.start();
                updateStatusIndicator('speechStatus', 'success', 'Active');
            }
        }

        function activateChatGPTVoiceSimple() {
            console.log('ü§ñ Activating ChatGPT voice (simple method)...');
            
            const chatFrame = document.getElementById('chatgptFrame');
            
            // Wait for ChatGPT to load, then try to activate voice
            setTimeout(() => {
                // Method 1: Try to click voice button directly
                try {
                    const iframeDoc = chatFrame.contentDocument || chatFrame.contentWindow.document;
                    
                    if (iframeDoc) {
                        // Look for voice/microphone buttons
                        const voiceSelectors = [
                            '[aria-label*="voice"]',
                            '[aria-label*="Voice"]',
                            '[data-testid*="voice"]',
                            'button:has([data-icon="microphone"])',
                            'button:contains("üé§")'
                        ];
                        
                        for (const selector of voiceSelectors) {
                            const button = iframeDoc.querySelector(selector);
                            if (button) {
                                button.click();
                                console.log('‚úÖ ChatGPT voice button clicked');
                                updateStatusIndicator('chatgptStatus', 'success', 'Voice Active');
                                showNotification('ü§ñ ChatGPT Voice On', 'Voice mode activated in ChatGPT.', 'success');
                                return;
                            }
                        }
                    }
                } catch (error) {
                    console.log('Direct voice activation blocked:', error);
                }
                
                // Method 2: Send activation message
                chatFrame.contentWindow.postMessage({
                    type: 'activate_voice',
                    source: 'portal'
                }, '*');
                
                updateStatusIndicator('chatgptStatus', 'warning', 'Voice Attempted');
                showNotification('ü§ñ ChatGPT Voice', 'Voice activation attempted. Look for microphone button in ChatGPT.', 'info');
                
            }, 3000);
        }

        function sendVoiceInputToChatGPT(text) {
            const chatFrame = document.getElementById('chatgptFrame');
            
            try {
                // Try to inject text directly into ChatGPT
                const iframeDoc = chatFrame.contentDocument || chatFrame.contentWindow.document;
                
                if (iframeDoc) {
                    const textArea = iframeDoc.querySelector('textarea');
                    const inputField = iframeDoc.querySelector('input[type="text"]');
                    
                    const targetInput = textArea || inputField;
                    
                    if (targetInput) {
                        targetInput.value = text;
                        targetInput.focus();
                        
                        // Trigger input events
                        targetInput.dispatchEvent(new Event('input', { bubbles: true }));
                        targetInput.dispatchEvent(new Event('change', { bubbles: true }));
                        
                        // Try to find and click send button
                        setTimeout(() => {
                            const sendButton = iframeDoc.querySelector('button[type="submit"]') ||
                                             iframeDoc.querySelector('[aria-label*="Send"]') ||
                                             iframeDoc.querySelector('button:last-of-type');
                            
                            if (sendButton) {
                                sendButton.click();
                                console.log('‚úÖ Voice input sent to ChatGPT');
                            }
                        }, 300);
                        
                        return true;
                    }
                }
            } catch (error) {
                console.log('Direct text injection blocked:', error);
            }
            
            // Fallback: Send via PostMessage
            chatFrame.contentWindow.postMessage({
                type: 'inject_text',
                text: text,
                autoSubmit: true
            }, '*');
            
            console.log('Voice input sent via PostMessage');
            return false;
        }

        function startSimpleMonitoring() {
            // Simple monitoring every 3 seconds
            setInterval(() => {
                // Check audio context
                if (window.portalAudioContext && window.portalAudioContext.state === 'running') {
                    updateStatusIndicator('speakerStatus', 'success', 'iPhone Speaker Active');
                }
                
                // Check microphone
                if (window.micStream && window.micStream.active) {
                    updateStatusIndicator('micStatus', 'success', 'iPhone Mic Active');
                }
                
                // Check speech recognition
                if (window.recognition) {
                    updateStatusIndicator('speechStatus', 'success', 'Voice Active');
                }
                
                // Check ChatGPT frame
                const chatFrame = document.getElementById('chatgptFrame');
                if (chatFrame.src.includes('chatgpt.com')) {
                    updateStatusIndicator('chatgptStatus', 'success', 'Connected');
                }
            }, 3000);
        }

        function initializePortalControlSystems() {
            console.log('üöÄ Initializing comprehensive portal control systems...');
            
            // Enhanced audio context for speaker forcing
            try {
                window.portalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Force resume audio context immediately
                if (window.portalAudioContext.state === 'suspended') {
                    window.portalAudioContext.resume().then(() => {
                        console.log('‚úÖ Portal audio context activated');
                        updateStatusIndicator('speakerStatus', 'success', 'Audio Context Active');
                    });
                }
                
                // Create enhanced speaker output nodes
                window.portalSpeakerOutput = window.portalAudioContext.createGain();
                window.portalSpeakerOutput.connect(window.portalAudioContext.destination);
                window.portalSpeakerOutput.gain.value = 1.0;
                
                // Test audio immediately
                playActivationTone();
                
                console.log('‚úÖ Portal audio context initialized for speaker control');
                
            } catch (error) {
                console.log('‚ùå Portal audio initialization error:', error);
                updateStatusIndicator('speakerStatus', 'warning', 'Audio Failed');
            }
            
            // Update status indicators with active states
            updateStatusIndicator('chatgptStatus', 'warning', 'Connecting...');
            updateStatusIndicator('speakerStatus', 'success', 'Initializing...');
            updateStatusIndicator('voiceSystemStatus', 'success', 'Ready');
            
            // Mark systems as initializing
            window.chatgptControlActive = true;
            window.voiceSystemActive = true;
            window.speakerForceActive = true;
        }

        function activateVoiceSystemImmediately() {
            console.log('üé§ Activating voice system immediately...');
            
            // Try to get microphone access right away
            navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 44100
                }
            })
            .then(function(stream) {
                console.log('‚úÖ Microphone access granted immediately');
                window.micStream = stream;
                
                // Connect to audio analysis
                if (window.audioAnalyser) {
                    const source = window.portalAudioContext.createMediaStreamSource(stream);
                    source.connect(window.audioAnalyser);
                }
                
                // Initialize speech recognition immediately
                initializeSpeechRecognitionNow();
                
                window.voiceSystemActive = true;
                updateStatusIndicator('voiceSystemStatus', 'success', 'Active');
                updateStatusIndicator('micStatus', 'success', 'Active');
                updateStatusIndicator('speechStatus', 'success', 'Listening');
                
                showNotification('üé§ Voice System Active!', 'Microphone and speech recognition are now active.', 'success');
                
            })
            .catch(function(error) {
                console.log('‚ö†Ô∏è Microphone access denied, trying bypass methods...');
                attemptMicrophoneBypass();
                updateStatusIndicator('micStatus', 'warning', 'Bypass Mode');
            });
        }

        function initializeSpeechRecognitionNow() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                window.recognition = new SpeechRecognition();
                
                window.recognition.continuous = true;
                window.recognition.interimResults = true;
                window.recognition.lang = 'en-US';
                
                window.recognition.onstart = function() {
                    console.log('‚úÖ Speech recognition started');
                    updateStatusIndicator('speechStatus', 'success', 'Listening');
                    playNotificationTone(523.25); // C5
                };
                
                window.recognition.onresult = function(event) {
                    let finalTranscript = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript;
                        }
                    }
                    
                    if (finalTranscript) {
                        console.log('üé§ Voice input received:', finalTranscript);
                        
                        // Immediately inject to ChatGPT
                        injectTextToChatGPT(finalTranscript);
                        
                        // Visual feedback
                        showNotification('üé§ Voice Captured', `"${finalTranscript.substring(0, 30)}..." ‚Üí ChatGPT`, 'info');
                        
                        playNotificationTone(659.25); // E5
                    }
                };
                
                window.recognition.onerror = function(event) {
                    console.log('üîÑ Speech recognition error, restarting:', event.error);
                    
                    // Auto-restart on error
                    if (window.voiceSystemActive) {
                        setTimeout(() => {
                            window.recognition.start();
                        }, 1000);
                    }
                };
                
                window.recognition.onend = function() {
                    console.log('üîÑ Speech recognition ended, restarting...');
                    
                    // Auto-restart if still active
                    if (window.voiceSystemActive) {
                        setTimeout(() => {
                            window.recognition.start();
                        }, 100);
                    }
                };
                
                // Start recognition immediately
                try {
                    window.recognition.start();
                    console.log('‚úÖ Speech recognition started successfully');
                } catch (error) {
                    console.log('‚ùå Speech recognition start failed:', error);
                }
            }
        }

        function establishChatGPTControlAggressively() {
            console.log('ü§ñ Establishing aggressive ChatGPT control...');
            
            const chatFrame = document.getElementById('chatgptFrame');
            
            // Method 1: Immediate script injection attempts
            setTimeout(() => attemptScriptInjection(), 1000);
            setTimeout(() => attemptScriptInjection(), 3000);
            setTimeout(() => attemptScriptInjection(), 5000);
            
            // Method 2: Continuous PostMessage attempts
            startContinuousPostMessage();
            
            // Method 3: Event monitoring and injection
            setupAdvancedEventMonitoring();
            
            // Method 4: Force voice activation attempts
            setTimeout(() => forceVoiceActivationAggressive(), 2000);
            setTimeout(() => forceVoiceActivationAggressive(), 5000);
            setTimeout(() => forceVoiceActivationAggressive(), 8000);
        }

        function attemptScriptInjection() {
            const chatFrame = document.getElementById('chatgptFrame');
            
            try {
                const iframeDoc = chatFrame.contentDocument || chatFrame.contentWindow.document;
                
                if (iframeDoc && !iframeDoc.querySelector('#portalControlScript')) {
                    const script = iframeDoc.createElement('script');
                    script.id = 'portalControlScript';
                    script.textContent = `
                        console.log('üöÄ Portal Control Script Loading...');
                        window.portalControlActive = true;
                        window.portalForceVoice = true;
                        
                        // Aggressive voice mode activation
                        function forceActivateVoice() {
                            const selectors = [
                                '[data-testid*="voice"]',
                                '[aria-label*="voice"]',
                                '[aria-label*="microphone"]',
                                '[title*="voice"]',
                                'button[class*="voice"]',
                                'button:has(svg[data-icon="microphone"])',
                                'button:has([data-icon="microphone"])',
                                '[role="button"]:has([data-icon="microphone"])'
                            ];
                            
                            for (const selector of selectors) {
                                try {
                                    const elements = document.querySelectorAll(selector);
                                    elements.forEach(element => {
                                        if (element && element.click) {
                                            element.click();
                                            console.log('‚úÖ Voice button clicked:', selector);
                                            return true;
                                        }
                                    });
                                } catch (e) {
                                    continue;
                                }
                            }
                            
                            // Alternative approach - find by text content
                            const buttons = document.querySelectorAll('button');
                            for (const button of buttons) {
                                const text = button.textContent || button.innerHTML || '';
                                const ariaLabel = button.getAttribute('aria-label') || '';
                                
                                if (text.includes('üé§') || 
                                    text.toLowerCase().includes('voice') ||
                                    text.toLowerCase().includes('microphone') ||
                                    ariaLabel.toLowerCase().includes('voice') ||
                                    ariaLabel.toLowerCase().includes('microphone')) {
                                    
                                    button.click();
                                    console.log('‚úÖ Voice button found by content and clicked');
                                    return true;
                                }
                            }
                            
                            return false;
                        }
                        
                        // Force voice activation every 3 seconds
                        setInterval(() => {
                            if (window.portalForceVoice) {
                                forceActivateVoice();
                            }
                        }, 3000);
                        
                        // Immediate activation attempt
                        setTimeout(forceActivateVoice, 1000);
                        
                        // Override audio settings for speaker output
                        if ('speechSynthesis' in window) {
                            const originalSpeak = speechSynthesis.speak;
                            speechSynthesis.speak = function(utterance) {
                                utterance.volume = 1.0;
                                utterance.rate = 0.9;
                                console.log('üîä Forcing speech synthesis to speaker');
                                return originalSpeak.call(this, utterance);
                            };
                        }
                        
                        // Monitor for text input and auto-send
                        window.addEventListener('message', function(event) {
                            if (event.data.type === 'inject_text' && event.data.text) {
                                const textArea = document.querySelector('textarea') || 
                                               document.querySelector('input[type="text"]') ||
                                               document.querySelector('[contenteditable="true"]');
                                
                                if (textArea) {
                                    textArea.value = event.data.text;
                                    textArea.textContent = event.data.text;
                                    
                                    // Trigger events
                                    textArea.dispatchEvent(new Event('input', { bubbles: true }));
                                    textArea.dispatchEvent(new Event('change', { bubbles: true }));
                                    textArea.focus();
                                    
                                    // Auto-submit if requested
                                    if (event.data.autoSubmit) {
                                        setTimeout(() => {
                                            const sendButton = document.querySelector('button[type="submit"]') || 
                                                             document.querySelector('[aria-label*="Send"]') ||
                                                             document.querySelector('button:last-of-type');
                                            
                                            if (sendButton) {
                                                sendButton.click();
                                                console.log('‚úÖ Text injected and sent automatically');
                                            }
                                        }, 500);
                                    }
                                    
                                    console.log('‚úÖ Text injected successfully:', event.data.text);
                                }
                            }
                        });
                        
                        console.log('‚úÖ Portal Control Script Active - Voice forcing enabled');
                    `;
                    
                    iframeDoc.head.appendChild(script);
                    console.log('‚úÖ Portal control script injected successfully');
                    
                    window.chatgptControlActive = true;
                    updateStatusIndicator('chatgptStatus', 'success', 'Script Injected');
                    updateStatusIndicator('connectionStatus', 'success', 'Script Active');
                    
                    return true;
                }
            } catch (error) {
                console.log('‚ùå Script injection blocked:', error);
                updateStatusIndicator('chatgptStatus', 'warning', 'Access Restricted');
            }
            
            return false;
        }

        function startContinuousPostMessage() {
            // Send control messages to ChatGPT every 5 seconds
            setInterval(() => {
                const chatFrame = document.getElementById('chatgptFrame');
                
                try {
                    // Voice activation message
                    chatFrame.contentWindow.postMessage({
                        type: 'force_voice_activation',
                        source: 'portal_control',
                        timestamp: Date.now()
                    }, '*');
                    
                    // Speaker forcing message
                    chatFrame.contentWindow.postMessage({
                        type: 'force_speaker_output',
                        volume: 1.0,
                        source: 'portal_control'
                    }, '*');
                    
                } catch (error) {
                    // Silent fail for security restrictions
                }
            }, 5000);
            
            console.log('‚úÖ Continuous PostMessage control started');
        }

        function setupAdvancedEventMonitoring() {
            const chatFrame = document.getElementById('chatgptFrame');
            
            // Monitor iframe load events
            chatFrame.addEventListener('load', function() {
                console.log('üîÑ ChatGPT iframe loaded, re-establishing control...');
                setTimeout(() => {
                    attemptScriptInjection();
                    forceVoiceActivationAggressive();
                }, 1000);
            });
            
            // Monitor for any audio events
            document.addEventListener('play', function(event) {
                if (event.target.tagName === 'AUDIO') {
                    console.log('üîä Audio detected, forcing speaker output');
                    forceSpeakerOutputEvent();
                }
            }, true);
            
            // Monitor for speech synthesis
            window.addEventListener('beforeunload', function() {
                if (window.speechSynthesis.speaking) {
                    console.log('üîä Speech synthesis detected');
                }
            });
        }

        function forceVoiceActivationAggressive() {
            console.log('üé§ Attempting aggressive voice activation...');
            
            const chatFrame = document.getElementById('chatgptFrame');
            
            try {
                // Method 1: Direct DOM access
                const iframeDoc = chatFrame.contentDocument || chatFrame.contentWindow.document;
                
                if (iframeDoc) {
                    const voiceSelectors = [
                        '[data-testid*="voice"]',
                        '[aria-label*="voice"]',
                        '[aria-label*="microphone"]',
                        'button[class*="voice"]',
                        'button:has(svg[data-icon="microphone"])'
                    ];
                    
                    for (const selector of voiceSelectors) {
                        const elements = iframeDoc.querySelectorAll(selector);
                        elements.forEach(element => {
                            if (element) {
                                element.click();
                                console.log('‚úÖ Voice button clicked:', selector);
                                updateStatusIndicator('voiceModeStatus', 'success', 'Activated');
                                showNotification('üé§ Voice Activated!', 'Voice button clicked successfully.', 'success');
                            }
                        });
                    }
                }
            } catch (error) {
                console.log('‚ùå Direct voice activation blocked:', error);
            }
            
            // Method 2: Script-based activation
            if (window.chatgptControlActive) {
                try {
                    chatFrame.contentWindow.portalForceVoice = true;
                    console.log('‚úÖ Script-based voice forcing activated');
                } catch (error) {
                    console.log('‚ùå Script communication blocked:', error);
                }
            }
            
            // Method 3: PostMessage activation
            chatFrame.contentWindow.postMessage({
                type: 'activate_voice_now',
                force: true,
                source: 'portal_aggressive'
            }, '*');
        }

        function forceAllSystemsActive() {
            console.log('üöÄ Forcing all systems to active state...');
            
            // Force speaker system active
            forceSpeakerOutputEvent();
            
            // Force voice system active
            if (!window.voiceSystemActive) {
                activateVoiceSystemImmediately();
            }
            
            // Force ChatGPT control active
            window.chatgptControlActive = true;
            
            // Update all status indicators to active
            updateStatusIndicator('chatgptStatus', 'success', 'Force Active');
            updateStatusIndicator('speakerStatus', 'success', 'Force Active');
            updateStatusIndicator('voiceSystemStatus', 'success', 'Force Active');
            updateStatusIndicator('connectionStatus', 'success', 'Force Active');
            updateStatusIndicator('voiceModeStatus', 'success', 'Force Active');
            
            // Global system flags
            window.voiceSystemActive = true;
            window.speakerForceActive = true;
            window.chatgptControlActive = true;
            
            showNotification('üöÄ All Systems Forced Active!', 'ChatGPT control, voice system, and speaker output are now active.', 'success');
        }

        function startContinuousMonitoring() {
            // Monitor all systems every 2 seconds
            setInterval(() => {
                // Check ChatGPT connection
                const chatFrame = document.getElementById('chatgptFrame');
                if (chatFrame.src && chatFrame.src.includes('chatgpt.com')) {
                    updateStatusIndicator('connectionStatus', 'success', 'Connected');
                }
                
                // Check audio context
                if (window.portalAudioContext && window.portalAudioContext.state === 'running') {
                    updateStatusIndicator('speakerStatus', 'success', 'Active');
                } else if (window.portalAudioContext) {
                    window.portalAudioContext.resume();
                }
                
                // Check voice system
                if (window.voiceSystemActive && window.recognition) {
                    updateStatusIndicator('voiceSystemStatus', 'success', 'Active');
                } else {
                    // Attempt to restart voice system
                    initializeSpeechRecognitionNow();
                }
                
                // Check microphone
                if (window.micStream && window.micStream.active) {
                    updateStatusIndicator('micStatus', 'success', 'Active');
                }
            }, 2000);
            
            console.log('‚úÖ Continuous monitoring started');
        }

        function setupAutoRetrySystem() {
            // Retry failed systems every 10 seconds
            setInterval(() => {
                // Retry ChatGPT control if failed
                if (!window.chatgptControlActive) {
                    console.log('üîÑ Retrying ChatGPT control...');
                    attemptScriptInjection();
                }
                
                // Retry voice system if failed
                if (!window.voiceSystemActive) {
                    console.log('üîÑ Retrying voice system...');
                    activateVoiceSystemImmediately();
                }
                
                // Retry speaker system if failed
                if (!window.speakerForceActive && window.portalAudioContext) {
                    console.log('üîÑ Retrying speaker system...');
                    window.portalAudioContext.resume();
                    window.speakerForceActive = true;
                }
                
                // Retry voice activation
                forceVoiceActivationAggressive();
                
            }, 10000);
            
            console.log('‚úÖ Auto-retry system activated');
        }

        // Helper functions for immediate activation
        function playActivationTone() {
            if (window.portalAudioContext) {
                const oscillator = window.portalAudioContext.createOscillator();
                const gainNode = window.portalAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(window.portalAudioContext.destination);
                
                oscillator.frequency.setValueAtTime(440, window.portalAudioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, window.portalAudioContext.currentTime);
                
                oscillator.start();
                oscillator.stop(window.portalAudioContext.currentTime + 0.2);
                
                console.log('üîä Activation tone played');
            }
        }

        function playNotificationTone(frequency) {
            if (window.portalAudioContext) {
                const oscillator = window.portalAudioContext.createOscillator();
                const gainNode = window.portalAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(window.portalAudioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, window.portalAudioContext.currentTime);
                gainNode.gain.setValueAtTime(0.05, window.portalAudioContext.currentTime);
                
                oscillator.start();
                oscillator.stop(window.portalAudioContext.currentTime + 0.1);
            }
        }

        function attemptMicrophoneBypass() {
            console.log('üîì Attempting microphone bypass methods...');
            
            // Try different audio constraints
            const constraints = [
                { audio: { echoCancellation: false, noiseSuppression: false } },
                { audio: { sampleRate: 22050 } },
                { audio: { channelCount: 1 } },
                { audio: true }
            ];
            
            async function tryConstraint(constraint) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraint);
                    console.log('‚úÖ Microphone bypass successful');
                    window.micStream = stream;
                    updateStatusIndicator('micStatus', 'success', 'Bypass Success');
                    return true;
                } catch (error) {
                    return false;
                }
            }
            
            // Try each constraint
            constraints.forEach((constraint, index) => {
                setTimeout(() => tryConstraint(constraint), index * 1000);
            });
        }

        function forceSpeakerOutputEvent() {
            console.log('üîä Forcing speaker output...');
            
            if (window.portalAudioContext) {
                window.portalAudioContext.resume();
                
                // Test tone to ensure speaker is active
                playActivationTone();
                
                window.speakerForceActive = true;
                updateStatusIndicator('speakerStatus', 'success', 'Speaker Forced');
            }
        }

        function establishChatGPTControl() {
            console.log('Establishing ChatGPT portal control...');
            
            const chatFrame = document.getElementById('chatgptFrame');
            
            // Method 1: Direct iframe control
            setTimeout(() => {
                try {
                    injectPortalControlScript();
                    updateStatusIndicator('chatgptStatus', 'success', 'Connected');
                } catch (error) {
                    console.log('Direct control failed, trying alternative methods...');
                    tryAlternativeControlMethods();
                }
            }, 3000);
            
            // Method 2: PostMessage control
            setupPostMessageControl();
            
            // Method 3: Event listener injection
            setupEventListenerControl();
        }

        function injectPortalControlScript() {
            const chatFrame = document.getElementById('chatgptFrame');
            
            try {
                const iframeDoc = chatFrame.contentDocument || chatFrame.contentWindow.document;
                
                if (iframeDoc) {
                    // Inject portal control script into ChatGPT
                    const script = iframeDoc.createElement('script');
                    script.textContent = `
                        // Portal Control Script for ChatGPT
                        window.portalControlActive = true;
                        
                        // Force voice mode activation
                        function activateVoiceMode() {
                            const voiceSelectors = [
                                '[data-testid*="voice"]',
                                '[aria-label*="voice"]',
                                '[aria-label*="speak"]',
                                'button[class*="voice"]',
                                'button:has(svg[data-icon="microphone"])'
                            ];
                            
                            for (const selector of voiceSelectors) {
                                const element = document.querySelector(selector);
                                if (element) {
                                    element.click();
                                    return true;
                                }
                            }
                            return false;
                        }
                        
                        // Monitor for voice activation
                        setInterval(() => {
                            if (window.portalShouldActivateVoice) {
                                activateVoiceMode();
                                window.portalShouldActivateVoice = false;
                            }
                        }, 1000);
                        
                        // Force speaker output
                        if ('speechSynthesis' in window) {
                            const originalSpeak = speechSynthesis.speak;
                            speechSynthesis.speak = function(utterance) {
                                utterance.volume = 1.0;
                                return originalSpeak.call(this, utterance);
                            };
                        }
                        
                        console.log('Portal control script injected successfully');
                    `;
                    
                    iframeDoc.head.appendChild(script);
                    console.log('Portal control script injected into ChatGPT');
                    
                    window.chatgptControlActive = true;
                    return true;
                }
            } catch (error) {
                console.log('Script injection blocked:', error);
            }
            
            return false;
        }

        function setupPostMessageControl() {
            // Set up bidirectional communication with ChatGPT
            window.addEventListener('message', function(event) {
                if (event.origin !== 'https://chatgpt.com') return;
                
                const data = event.data;
                
                if (data.type === 'voice_status') {
                    updateStatusIndicator('voiceModeStatus', 
                        data.active ? 'success' : 'warning', 
                        data.active ? 'Active' : 'Inactive');
                }
                
                if (data.type === 'audio_output') {
                    forceSpeakerOutput();
                }
            });
            
            console.log('PostMessage control established');
        }

        function setupEventListenerControl() {
            // Monitor ChatGPT iframe for changes
            const chatFrame = document.getElementById('chatgptFrame');
            
            chatFrame.addEventListener('load', function() {
                setTimeout(() => {
                    establishChatGPTControl();
                }, 1000);
            });
            
            // Monitor for audio events
            document.addEventListener('play', function(event) {
                if (event.target.tagName === 'AUDIO') {
                    forceSpeakerOutput();
                }
            }, true);
        }

        // Simplified iPhone Audio Control Functions
        function activateIPhoneMic() {
            const btn = event.target;
            btn.innerHTML = 'üé§ Activating...';
            btn.disabled = true;
            
            console.log('üì± Activating iPhone microphone...');
            
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    window.micStream = stream;
                    
                    console.log('‚úÖ iPhone microphone activated');
                    updateStatusIndicator('micStatus', 'success', 'iPhone Mic Active');
                    
                    // Start speech recognition
                    startIPhoneSpeechRecognition();
                    
                    btn.innerHTML = 'üé§ iPhone Mic Active!';
                    btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                    
                    showNotification('üé§ iPhone Mic Active', 'iPhone microphone is now active and listening for voice input.', 'success');
                    
                    // Connect to audio visualizer
                    if (window.audioAnalyser && window.portalAudioContext) {
                        const source = window.portalAudioContext.createMediaStreamSource(stream);
                        source.connect(window.audioAnalyser);
                    }
                })
                .catch(function(error) {
                    console.log('‚ùå iPhone microphone access denied:', error);
                    updateStatusIndicator('micStatus', 'warning', 'Access Denied');
                    
                    btn.innerHTML = 'üé§ Permission Denied';
                    btn.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                    
                    showNotification('üé§ Mic Permission', 'Please allow microphone access in your browser settings.', 'warning');
                });
            
            setTimeout(() => {
                btn.disabled = false;
                if (btn.innerHTML.includes('Activating')) {
                    btn.innerHTML = 'üé§ Activate iPhone Mic';
                    btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                }
            }, 3000);
        }

        function forceIPhoneSpeaker() {
            const btn = event.target;
            btn.innerHTML = 'üîä Forcing...';
            btn.disabled = true;
            
            console.log('üì± Forcing iPhone speaker output...');
            
            try {
                // Force audio context to iPhone speaker
                if (window.portalAudioContext) {
                    window.portalAudioContext.resume().then(() => {
                        console.log('‚úÖ iPhone audio context active');
                    });
                }
                
                // Override speech synthesis for iPhone speaker
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel(); // Clear any existing speech
                    
                    // Test iPhone speaker with speech
                    const testUtterance = new SpeechSynthesisUtterance('iPhone speaker is now active');
                    testUtterance.volume = 1.0;
                    testUtterance.rate = 0.9;
                    window.speechSynthesis.speak(testUtterance);
                    
                    console.log('üîä iPhone speaker test speech played');
                }
                
                // Play test tone through iPhone speaker
                playIPhoneTestSound();
                
                updateStatusIndicator('speakerStatus', 'success', 'iPhone Speaker Forced');
                
                btn.innerHTML = 'üîä iPhone Speaker Active!';
                btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                
                showNotification('üîä iPhone Speaker Active', 'Audio output is now forced to iPhone speaker at maximum volume.', 'success');
                
            } catch (error) {
                console.log('‚ùå iPhone speaker error:', error);
                updateStatusIndicator('speakerStatus', 'warning', 'Speaker Error');
                
                btn.innerHTML = 'üîä Speaker Error';
                btn.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
            }
            
            setTimeout(() => {
                btn.disabled = false;
                if (btn.innerHTML.includes('Forcing')) {
                    btn.innerHTML = 'üîä Force iPhone Speaker';
                    btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                }
            }, 3000);
        }

        function setupIPhoneAudioComplete() {
            const btn = event.target;
            btn.innerHTML = 'üì± Setting Up...';
            btn.disabled = true;
            
            console.log('üì± Complete iPhone audio setup...');
            showNotification('üì± iPhone Setup', 'Setting up iPhone microphone and speaker...', 'info');
            
            // Step 1: Force iPhone microphone and speaker
            forceIPhoneMicAndSpeaker();
            
            // Step 2: Activate ChatGPT voice after delay
            setTimeout(() => {
                activateChatGPTVoiceSimple();
            }, 2000);
            
            // Step 3: Test audio systems
            setTimeout(() => {
                testIPhoneAudio();
            }, 4000);
            
            btn.innerHTML = 'üì± iPhone Setup Complete!';
            btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
            
            setTimeout(() => {
                btn.innerHTML = 'üì± Setup iPhone Audio';
                btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                btn.disabled = false;
                
                showNotification('üì± Setup Complete', 'iPhone audio setup completed. Test the microphone and speaker.', 'success');
            }, 3000);
        }

        function testIPhoneAudio() {
            const btn = event.target;
            if (btn) {
                btn.innerHTML = 'üîä Testing...';
                btn.disabled = true;
            }
            
            console.log('üß™ Testing iPhone audio systems...');
            
            // Test 1: iPhone speaker with tone
            if (window.portalAudioContext) {
                playIPhoneTestSound();
            }
            
            // Test 2: iPhone speaker with speech
            if ('speechSynthesis' in window) {
                const testSpeech = new SpeechSynthesisUtterance('iPhone audio test. Can you hear this clearly?');
                testSpeech.volume = 1.0;
                testSpeech.rate = 0.8;
                window.speechSynthesis.speak(testSpeech);
            }
            
            // Test 3: Check microphone status
            const micActive = window.micStream && window.micStream.active;
            const speakerActive = window.portalAudioContext && window.portalAudioContext.state === 'running';
            
            let testResult = 'üß™ iPhone Audio Test Results:\n\n';
            testResult += `üé§ Microphone: ${micActive ? '‚úÖ Active' : '‚ùå Inactive'}\n`;
            testResult += `üîä Speaker: ${speakerActive ? '‚úÖ Active' : '‚ùå Inactive'}\n`;
            testResult += `üó£Ô∏è Speech Synthesis: ${('speechSynthesis' in window) ? '‚úÖ Available' : '‚ùå Not Available'}\n`;
            
            if (micActive && speakerActive) {
                testResult += '\n‚úÖ iPhone audio is working correctly!';
                showNotification('üß™ Test Results', testResult, 'success');
            } else {
                testResult += '\n‚ö†Ô∏è Some audio features may need activation.';
                showNotification('üß™ Test Results', testResult, 'warning');
            }
            
            if (btn) {
                btn.innerHTML = 'üß™ Test Complete!';
                btn.style.background = micActive && speakerActive ? 
                    'linear-gradient(135deg, #27ae60, #2ecc71)' : 
                    'linear-gradient(135deg, #f39c12, #e67e22)';
                
                setTimeout(() => {
                    btn.innerHTML = 'üîä Test iPhone Audio';
                    btn.style.background = 'linear-gradient(135deg, #f39c12, #e67e22)';
                    btn.disabled = false;
                }, 3000);
            }
        }

        function setIPhoneVolume(value) {
            console.log(`üîä Setting iPhone volume to ${value}%`);
            
            // Set audio context gain
            if (window.speakerOutput) {
                window.speakerOutput.gain.value = value / 100;
            }
            
            // Force all audio elements to this volume
            const audioElements = document.querySelectorAll('audio, video');
            audioElements.forEach(audio => {
                audio.volume = value / 100;
            });
            
            updateStatusIndicator('speakerStatus', 'success', `Volume ${value}%`);
        }

        function sendTestMessage() {
            const testMessage = "Hello ChatGPT! This is a test message from the iPhone portal. Please respond with voice if voice mode is active.";
            
            sendVoiceInputToChatGPT(testMessage);
            
            showNotification('üìù Test Message', 'Test message sent to ChatGPT. Check for response.', 'info');
        }

        function checkAudioStatus() {
            const micActive = window.micStream && window.micStream.active;
            const speakerActive = window.portalAudioContext && window.portalAudioContext.state === 'running';
            const speechActive = window.recognition !== null;
            const chatgptLoaded = document.getElementById('chatgptFrame').src.includes('chatgpt.com');
            
            let statusReport = 'üìä iPhone Audio Status:\n\n';
            statusReport += `üé§ iPhone Microphone: ${micActive ? '‚úÖ Active' : '‚ùå Inactive'}\n`;
            statusReport += `üîä iPhone Speaker: ${speakerActive ? '‚úÖ Active' : '‚ùå Inactive'}\n`;
            statusReport += `üó£Ô∏è Speech Recognition: ${speechActive ? '‚úÖ Active' : '‚ùå Inactive'}\n`;
            statusReport += `ü§ñ ChatGPT Loaded: ${chatgptLoaded ? '‚úÖ Yes' : '‚ùå No'}\n\n`;
            
            const activeCount = [micActive, speakerActive, speechActive, chatgptLoaded].filter(Boolean).length;
            statusReport += `üìà System Health: ${activeCount}/4 components active`;
            
            const statusType = activeCount >= 3 ? 'success' : activeCount >= 2 ? 'warning' : 'error';
            showNotification('üìä Audio Status', statusReport, statusType);
            
            console.log('üìä Audio status check completed');
        }

        function resetAudioSystems() {
            const btn = event.target;
            btn.innerHTML = 'üîÑ Resetting...';
            btn.disabled = true;
            
            console.log('üîÑ Resetting iPhone audio systems...');
            showNotification('üîÑ Reset Audio', 'Resetting all iPhone audio systems...', 'warning');
            
            // Stop current systems
            if (window.recognition) {
                window.recognition.stop();
                window.recognition = null;
            }
            
            if (window.micStream) {
                window.micStream.getTracks().forEach(track => track.stop());
                window.micStream = null;
            }
            
            if (window.portalAudioContext) {
                window.portalAudioContext.close();
                window.portalAudioContext = null;
            }
            
            // Reset status indicators
            updateStatusIndicator('micStatus', 'warning', 'Reset');
            updateStatusIndicator('speakerStatus', 'warning', 'Reset');
            updateStatusIndicator('speechStatus', 'warning', 'Reset');
            
            // Reinitialize after 2 seconds
            setTimeout(() => {
                console.log('üîÑ Reinitializing iPhone audio...');
                initializeSimpleAudioControl();
                
                setTimeout(() => {
                    forceIPhoneMicAndSpeaker();
                    showNotification('üîÑ Reset Complete', 'iPhone audio systems have been reset and reinitialized.', 'success');
                }, 1000);
                
            }, 2000);
            
            btn.innerHTML = 'üîÑ Reset Complete!';
            btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
            
            setTimeout(() => {
                btn.innerHTML = 'üîÑ Reset Audio';
                btn.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                btn.disabled = false;
            }, 4000);
        }

        function refreshChatGPT() {
            const chatgptFrame = document.getElementById('chatgptFrame');
            
            showNotification('üîÑ Refreshing', 'Reloading ChatGPT conversation...', 'info');
            updateStatusIndicator('chatgptStatus', 'warning', 'Refreshing...');
            
            // Reload the specific ChatGPT conversation
            chatgptFrame.src = 'https://chatgpt.com/c/685f5529-0888-800c-b96a-008419428418';
            
            // Re-activate voice after reload
            setTimeout(() => {
                activateChatGPTVoiceSimple();
                updateStatusIndicator('chatgptStatus', 'success', 'Refreshed');
                showNotification('üîÑ Refresh Complete', 'ChatGPT conversation reloaded.', 'success');
            }, 5000);
        }

        function attemptDirectVoiceClick() {
            const chatFrame = document.getElementById('chatgptFrame');
            
            try {
                const iframeDoc = chatFrame.contentDocument || chatFrame.contentWindow.document;
                
                if (iframeDoc) {
                    // Comprehensive selector list for voice buttons
                    const voiceSelectors = [
                        '[data-testid*="voice"]',
                        '[aria-label*="voice"]',
                        '[aria-label*="microphone"]',
                        '[aria-label*="Voice"]',
                        '[aria-label*="Microphone"]',
                        '[title*="voice"]',
                        '[title*="Voice"]',
                        'button[class*="voice"]',
                        'button[class*="Voice"]',
                        'button:has(svg[data-icon="microphone"])',
                        'button:has([data-icon="microphone"])',
                        '[role="button"]:has([data-icon="microphone"])',
                        'button:has(svg[class*="microphone"])',
                        'button:has(svg[class*="voice"])'
                    ];
                    
                    let found = false;
                    
                    for (const selector of voiceSelectors) {
                        try {
                            const elements = iframeDoc.querySelectorAll(selector);
                            elements.forEach(element => {
                                if (element && !found) {
                                    element.click();
                                    console.log('‚úÖ Voice button clicked via selector:', selector);
                                    showNotification('üé§ Direct Click!', 'Voice button found and clicked directly.', 'success');
                                    updateStatusIndicator('voiceModeStatus', 'success', 'Direct Click');
                                    found = true;
                                }
                            });
                        } catch (e) {
                            continue;
                        }
                    }
                    
                    // Fallback: search by text content and attributes
                    if (!found) {
                        const allButtons = iframeDoc.querySelectorAll('button, [role="button"], [tabindex="0"]');
                        
                        for (const button of allButtons) {
                            const text = (button.textContent || '').toLowerCase();
                            const ariaLabel = (button.getAttribute('aria-label') || '').toLowerCase();
                            const title = (button.getAttribute('title') || '').toLowerCase();
                            const className = (button.className || '').toLowerCase();
                            
                            if (text.includes('voice') || text.includes('microphone') || text.includes('üé§') ||
                                ariaLabel.includes('voice') || ariaLabel.includes('microphone') ||
                                title.includes('voice') || title.includes('microphone') ||
                                className.includes('voice') || className.includes('microphone')) {
                                
                                button.click();
                                console.log('‚úÖ Voice button found by content analysis and clicked');
                                showNotification('üé§ Content Match!', 'Voice button found by content analysis.', 'success');
                                updateStatusIndicator('voiceModeStatus', 'success', 'Content Match');
                                found = true;
                                break;
                            }
                        }
                    }
                    
                    return found;
                }
            } catch (error) {
                console.log('Direct voice click blocked:', error);
                return false;
            }
            
            return false;
        }

        function forceSpeakerOutput() {
            console.log('üîä Forcing audio output to phone speaker...');
            
            const btn = event.target;
            if (btn) {
                btn.innerHTML = 'üì¢ Forcing...';
                btn.disabled = true;
            }
            
            try {
                // Method 1: Force audio context to resume and max volume
                if (window.portalAudioContext) {
                    window.portalAudioContext.resume().then(() => {
                        console.log('‚úÖ Audio context resumed');
                        
                        // Set maximum gain
                        if (window.portalSpeakerOutput) {
                            window.portalSpeakerOutput.gain.value = 1.0;
                        }
                        
                        // Play test tone at full volume
                        playLoudTestTone();
                        
                        updateStatusIndicator('speakerStatus', 'success', 'Context Resumed');
                    });
                }
                
                // Method 2: Force all existing audio elements to max volume
                const audioElements = document.querySelectorAll('audio, video');
                audioElements.forEach(audio => {
                    audio.volume = 1.0;
                    audio.muted = false;
                    console.log('üîä Audio element volume forced to maximum');
                });
                
                // Method 3: Override ChatGPT audio via PostMessage
                const chatFrame = document.getElementById('chatgptFrame');
                chatFrame.contentWindow.postMessage({
                    type: 'force_audio_output',
                    volume: 1.0,
                    muted: false,
                    route: 'speaker'
                }, '*');
                
                // Method 4: Override speech synthesis globally
                if ('speechSynthesis' in window) {
                    // Store original speak function
                    if (!window.originalSpeak) {
                        window.originalSpeak = speechSynthesis.speak;
                    }
                    
                    // Override with forced volume
                    speechSynthesis.speak = function(utterance) {
                        utterance.volume = 1.0;
                        utterance.rate = 0.9;
                        utterance.pitch = 1.0;
                        console.log('üîä Speech synthesis forced to speaker with max volume');
                        return window.originalSpeak.call(this, utterance);
                    };
                }
                
                // Method 5: Try to select audio output device
                if (navigator.mediaDevices && navigator.mediaDevices.selectAudioOutput) {
                    navigator.mediaDevices.selectAudioOutput().then(device => {
                        console.log('‚úÖ Audio output device selected:', device.label);
                        updateStatusIndicator('speakerStatus', 'success', device.label || 'Device Selected');
                        document.getElementById('audioRouteDisplay').textContent = `Audio Route: ${device.label || 'Selected Device'}`;
                    }).catch(error => {
                        console.log('Audio device selection not available:', error);
                    });
                }
                
                // Method 6: Continuous volume monitoring and forcing
                if (!window.volumeForceInterval) {
                    window.volumeForceInterval = setInterval(() => {
                        // Keep forcing all audio to max volume
                        const allAudio = document.querySelectorAll('audio, video');
                        allAudio.forEach(audio => {
                            if (audio.volume < 1.0) {
                                audio.volume = 1.0;
                            }
                            if (audio.muted) {
                                audio.muted = false;
                            }
                        });
                        
                        // Keep audio context running
                        if (window.portalAudioContext && window.portalAudioContext.state !== 'running') {
                            window.portalAudioContext.resume();
                        }
                    }, 1000);
                }
                
                window.speakerForceActive = true;
                
                showNotification('üì¢ Speaker Forced!', 'Multiple methods activated to force phone speaker output at maximum volume.', 'success');
                updateStatusIndicator('speakerStatus', 'success', 'Multi-Force Active');
                document.getElementById('audioRouteDisplay').textContent = 'Audio Route: Phone Speaker (Multi-Force Active)';
                
            } catch (error) {
                console.log('Speaker forcing error:', error);
                showNotification('üì¢ Force Partial', 'Some speaker forcing methods failed, but others may be active.', 'warning');
                updateStatusIndicator('speakerStatus', 'warning', 'Partial Force');
            }
            
            if (btn) {
                btn.innerHTML = 'üì¢ Multi-Force Active!';
                btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                
                setTimeout(() => {
                    btn.innerHTML = 'üì¢ Force Phone Speaker';
                    btn.disabled = false;
                }, 3000);
            }
        }

        function playLoudTestTone() {
            if (window.portalAudioContext) {
                const oscillator = window.portalAudioContext.createOscillator();
                const gainNode = window.portalAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(window.portalAudioContext.destination);
                
                oscillator.frequency.setValueAtTime(880, window.portalAudioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, window.portalAudioContext.currentTime); // Loud test tone
                
                oscillator.start();
                oscillator.stop(window.portalAudioContext.currentTime + 0.5);
                
                console.log('üîä Loud test tone played at maximum volume');
            }
        }

        function activatePortalVoiceMode() {
            const btn = event.target;
            btn.innerHTML = 'üéôÔ∏è Activating...';
            btn.disabled = true;
            
            console.log('üéôÔ∏è Activating portal voice mode with aggressive methods...');
            
            // Method 1: Immediate microphone access with multiple attempts
            const micConstraints = [
                { 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 48000
                    }
                },
                { 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                },
                { audio: true }
            ];
            
            async function tryMicAccess(constraints, index = 0) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints[index]);
                    console.log('‚úÖ Microphone access granted with constraints', index);
                    
                    window.micStream = stream;
                    
                    // Connect to audio analysis immediately
                    if (window.audioAnalyser) {
                        const source = window.portalAudioContext.createMediaStreamSource(stream);
                        source.connect(window.audioAnalyser);
                        console.log('‚úÖ Microphone connected to audio analyser');
                    }
                    
                    // Start speech recognition immediately
                    initializeSpeechRecognitionNow();
                    
                    window.voiceSystemActive = true;
                    updateStatusIndicator('voiceSystemStatus', 'success', 'Active');
                    updateStatusIndicator('micStatus', 'success', 'Active');
                    updateStatusIndicator('speechStatus', 'success', 'Listening');
                    
                    btn.innerHTML = 'üéôÔ∏è Voice Active!';
                    btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                    
                    showNotification('üéôÔ∏è Voice Activated!', 'Microphone access granted and speech recognition started.', 'success');
                    
                    return true;
                    
                } catch (error) {
                    console.log(`‚ùå Microphone attempt ${index + 1} failed:`, error);
                    
                    if (index < constraints.length - 1) {
                        // Try next constraint
                        return tryMicAccess(constraints, index + 1);
                    } else {
                        // All attempts failed, try bypass methods
                        console.log('üîì All microphone attempts failed, trying bypass...');
                        attemptAdvancedMicrophoneBypass();
                        
                        btn.innerHTML = 'üéôÔ∏è Bypass Mode';
                        btn.style.background = 'linear-gradient(135deg, #f39c12, #e67e22)';
                        
                        updateStatusIndicator('micStatus', 'warning', 'Bypass Attempted');
                        showNotification('üîì Mic Bypass', 'Microphone access denied. Bypass methods activated.', 'warning');
                        
                        return false;
                    }
                }
            }
            
            // Start microphone access attempts
            tryMicAccess(micConstraints);
            
            // Method 2: Force speech recognition even without explicit mic access
            setTimeout(() => {
                if (!window.recognition) {
                    initializeSpeechRecognitionNow();
                }
            }, 2000);
            
            // Method 3: Enable continuous voice forcing
            window.voiceSystemActive = true;
            
            setTimeout(() => {
                btn.disabled = false;
                if (btn.innerHTML.includes('Activating')) {
                    btn.innerHTML = 'üéôÔ∏è Activate Voice';
                    btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                }
            }, 3000);
        }

        function attemptAdvancedMicrophoneBypass() {
            console.log('üîì Attempting advanced microphone bypass methods...');
            
            // Method 1: Request permissions explicitly
            if (navigator.permissions) {
                navigator.permissions.query({ name: 'microphone' }).then(result => {
                    console.log('Microphone permission state:', result.state);
                    if (result.state === 'granted') {
                        // Try again with granted permission
                        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                            window.micStream = stream;
                            updateStatusIndicator('micStatus', 'success', 'Bypass Success');
                        });
                    }
                });
            }
            
            // Method 2: Try getUserMedia on user interaction
            document.addEventListener('click', function enableMicOnClick() {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        console.log('‚úÖ Microphone bypass successful via user interaction');
                        window.micStream = stream;
                        window.microphoneBypassActive = true;
                        updateStatusIndicator('micStatus', 'success', 'Click Bypass');
                        
                        // Connect to analysis
                        if (window.audioAnalyser) {
                            const source = window.portalAudioContext.createMediaStreamSource(stream);
                            source.connect(window.audioAnalyser);
                        }
                        
                        initializeSpeechRecognitionNow();
                        
                    })
                    .catch(error => {
                        console.log('Click bypass also failed:', error);
                    });
                
                // Remove listener after first attempt
                document.removeEventListener('click', enableMicOnClick);
            }, { once: true });
            
            // Method 3: Simulate user gesture
            setTimeout(() => {
                const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                });
                document.dispatchEvent(clickEvent);
            }, 1000);
            
            showNotification('üîì Advanced Bypass', 'Advanced microphone bypass methods activated. Try clicking anywhere.', 'warning');
        }

        function forceSpeakerOutput() {
            console.log('Forcing audio output to phone speaker...');
            
            const btn = event.target;
            if (btn) {
                btn.innerHTML = 'üì¢ Forcing...';
                btn.disabled = true;
            }
            
            try {
                // Method 1: Audio Context routing
                if (window.portalAudioContext) {
                    window.portalAudioContext.resume();
                    
                    // Force audio to default output (phone speaker)
                    if (navigator.mediaDevices && navigator.mediaDevices.selectAudioOutput) {
                        navigator.mediaDevices.selectAudioOutput()
                            .then(device => {
                                console.log('Audio output device selected:', device);
                                updateStatusIndicator('speakerStatus', 'success', 'Phone Speaker');
                                document.getElementById('audioRouteDisplay').textContent = 'Audio Route: Phone Speaker (Forced)';
                            })
                            .catch(error => {
                                console.log('Audio output selection failed:', error);
                            });
                    }
                }
                
                // Method 2: Force all audio elements to max volume
                const audioElements = document.querySelectorAll('audio');
                audioElements.forEach(audio => {
                    audio.volume = 1.0;
                    audio.muted = false;
                });
                
                // Method 3: Override ChatGPT audio settings
                if (window.chatgptControlActive) {
                    const chatFrame = document.getElementById('chatgptFrame');
                    chatFrame.contentWindow.postMessage({
                        type: 'force_speaker_output',
                        volume: 1.0
                    }, 'https://chatgpt.com');
                }
                
                // Method 4: Test speaker with forced audio
                const oscillator = window.portalAudioContext.createOscillator();
                const gainNode = window.portalAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(window.portalAudioContext.destination);
                
                oscillator.frequency.setValueAtTime(880, window.portalAudioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, window.portalAudioContext.currentTime);
                
                oscillator.start();
                oscillator.stop(window.portalAudioContext.currentTime + 0.3);
                
                window.speakerForceActive = true;
                
                showNotification('üì¢ Speaker Forced!', 'Audio output has been forced to phone speaker.', 'success');
                updateStatusIndicator('speakerStatus', 'success', 'Phone Speaker (Forced)');
                
            } catch (error) {
                console.log('Speaker forcing error:', error);
                showNotification('üì¢ Force Failed', 'Speaker forcing encountered an error. Some methods may still be active.', 'warning');
            }
            
            if (btn) {
                btn.innerHTML = 'üì¢ Speaker Forced!';
                btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                
                setTimeout(() => {
                    btn.innerHTML = 'üì¢ Force Phone Speaker';
                    btn.disabled = false;
                }, 3000);
            }
        }

        function activatePortalVoiceMode() {
            const btn = event.target;
            btn.innerHTML = 'üéôÔ∏è Activating...';
            btn.disabled = true;
            
            // Comprehensive voice activation
            navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 48000
                }
            })
            .then(function(stream) {
                window.micStream = stream;
                
                // Connect to audio analysis
                const source = window.portalAudioContext.createMediaStreamSource(stream);
                source.connect(window.audioAnalyser);
                
                // Initialize speech recognition
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    window.recognition = new SpeechRecognition();
                    
                    window.recognition.continuous = true;
                    window.recognition.interimResults = true;
                    window.recognition.lang = 'en-US';
                    
                    window.recognition.onresult = function(event) {
                        let finalTranscript = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            if (event.results[i].isFinal) {
                                finalTranscript += event.results[i][0].transcript;
                            }
                        }
                        
                        if (finalTranscript) {
                            injectTextToChatGPT(finalTranscript);
                        }
                    };
                    
                    window.recognition.start();
                }
                
                window.voiceSystemActive = true;
                updateStatusIndicator('voiceSystemStatus', 'success', 'Active');
                updateStatusIndicator('micStatus', 'success', 'Active');
                updateStatusIndicator('speechStatus', 'success', 'Listening');
                
                btn.innerHTML = 'üéôÔ∏è Voice Active!';
                btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                
                showNotification('üéôÔ∏è Voice Activated!', 'Portal voice mode is now fully active with speech recognition.', 'success');
            })
            .catch(function(error) {
                console.log('Voice activation error:', error);
                
                // Try bypass methods
                bypassMicrophoneRestrictions();
                
                btn.innerHTML = 'üéôÔ∏è Bypass Mode';
                btn.style.background = 'linear-gradient(135deg, #f39c12, #e67e22)';
            });
            
            setTimeout(() => {
                btn.disabled = false;
            }, 2000);
        }

        function injectTextToChatGPT(text = null) {
            const textInput = text || document.getElementById('textToInject').value;
            
            if (!textInput) {
                showNotification('üìù No Text', 'Please enter text to inject into ChatGPT.', 'warning');
                return;
            }
            
            const chatFrame = document.getElementById('chatgptFrame');
            
            try {
                // Method 1: Direct textarea injection
                const iframeDoc = chatFrame.contentDocument || chatFrame.contentWindow.document;
                
                if (iframeDoc) {
                    const textArea = iframeDoc.querySelector('textarea') || iframeDoc.querySelector('input[type="text"]');
                    
                    if (textArea) {
                        textArea.value = textInput;
                        textArea.focus();
                        
                        // Trigger events
                        textArea.dispatchEvent(new Event('input', { bubbles: true }));
                        textArea.dispatchEvent(new Event('change', { bubbles: true }));
                        
                        // Auto-submit
                        setTimeout(() => {
                            const sendButton = iframeDoc.querySelector('button[type="submit"]') || 
                                             iframeDoc.querySelector('[aria-label*="Send"]') ||
                                             iframeDoc.querySelector('button:last-of-type');
                            
                            if (sendButton) {
                                sendButton.click();
                                showNotification('üìù Text Sent!', 'Message injected and sent to ChatGPT successfully.', 'success');
                            }
                        }, 500);
                        
                        return;
                    }
                }
            } catch (error) {
                console.log('Direct injection blocked:', error);
            }
            
            // Method 2: PostMessage injection
            chatFrame.contentWindow.postMessage({
                type: 'inject_text',
                text: textInput,
                autoSubmit: true
            }, 'https://chatgpt.com');
            
            showNotification('üìù Text Injected', 'Text sent to ChatGPT via portal communication.', 'info');
            
            // Clear input
            if (!text) {
                document.getElementById('textToInject').value = '';
            }
        }

        function bypassMicrophoneRestrictions() {
            console.log('Attempting microphone bypass...');
            
            // Method 1: Multiple permission requests
            const requestPermissions = async () => {
                const permissions = ['microphone'];
                
                for (const permission of permissions) {
                    try {
                        const result = await navigator.permissions.query({ name: permission });
                        console.log(`${permission} permission:`, result.state);
                    } catch (error) {
                        console.log(`Permission query failed for ${permission}:`, error);
                    }
                }
            };
            
            requestPermissions();
            
            // Method 2: Silent audio context activation
            if (window.portalAudioContext) {
                window.portalAudioContext.resume();
            }
            
            // Method 3: User gesture simulation
            document.addEventListener('click', function enableAudio() {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        console.log('Microphone access granted via bypass');
                        window.microphoneBypassActive = true;
                        updateStatusIndicator('micStatus', 'success', 'Bypass Active');
                    })
                    .catch(error => {
                        console.log('Bypass failed:', error);
                    });
                
                document.removeEventListener('click', enableAudio);
            }, { once: true });
            
            showNotification('üîì Bypass Active', 'Microphone bypass methods activated. Click anywhere to complete.', 'warning');
        }

        function runAudioDiagnostics() {
            const btn = event.target;
            btn.innerHTML = 'üîç Running...';
            btn.disabled = true;
            
            console.log('üîç Running comprehensive audio diagnostics...');
            
            const diagnostics = {
                // Audio System
                audioContext: !!window.portalAudioContext,
                audioContextState: window.portalAudioContext ? window.portalAudioContext.state : 'none',
                speechSynthesis: 'speechSynthesis' in window,
                mediaDevices: !!navigator.mediaDevices,
                
                // Portal Control Systems
                chatgptControl: window.chatgptControlActive,
                voiceSystem: window.voiceSystemActive,
                speakerForce: window.speakerForceActive,
                microphoneBypass: window.microphoneBypassActive,
                
                // Active Components
                micStream: window.micStream ? window.micStream.active : false,
                speechRecognition: !!window.recognition,
                audioAnalyser: !!window.audioAnalyser,
                soundDetection: window.soundDetectionActive,
                
                // Browser Capabilities
                webkitSpeechRecognition: 'webkitSpeechRecognition' in window,
                speechRecognitionAPI: 'SpeechRecognition' in window,
                audioOutputSelection: !!(navigator.mediaDevices && navigator.mediaDevices.selectAudioOutput),
                
                // Current Status
                chatgptFrameLoaded: document.getElementById('chatgptFrame').src.includes('chatgpt.com'),
                portalInitialized: window.portalControlActive || false
            };
            
            console.log('üìä Complete diagnostics:', diagnostics);
            
            // Count successful systems
            const totalSystems = Object.keys(diagnostics).length;
            const activeSystems = Object.values(diagnostics).filter(Boolean).length;
            const successRate = Math.round((activeSystems / totalSystems) * 100);
            
            // Generate detailed report
            let reportText = `üîç PORTAL DIAGNOSTICS REPORT\n\n`;
            reportText += `System Health: ${successRate}% (${activeSystems}/${totalSystems})\n\n`;
            
            reportText += `üîä AUDIO SYSTEMS:\n`;
            reportText += `Audio Context: ${diagnostics.audioContext ? '‚úÖ' : '‚ùå'} (${diagnostics.audioContextState})\n`;
            reportText += `Speech Synthesis: ${diagnostics.speechSynthesis ? '‚úÖ' : '‚ùå'}\n`;
            reportText += `Media Devices: ${diagnostics.mediaDevices ? '‚úÖ' : '‚ùå'}\n`;
            reportText += `Audio Output Selection: ${diagnostics.audioOutputSelection ? '‚úÖ' : '‚ùå'}\n\n`;
            
            reportText += `ü§ñ PORTAL CONTROL:\n`;
            reportText += `ChatGPT Control: ${diagnostics.chatgptControl ? '‚úÖ' : '‚ùå'}\n`;
            reportText += `Voice System: ${diagnostics.voiceSystem ? '‚úÖ' : '‚ùå'}\n`;
            reportText += `Speaker Force: ${diagnostics.speakerForce ? '‚úÖ' : '‚ùå'}\n`;
            reportText += `ChatGPT Frame: ${diagnostics.chatgptFrameLoaded ? '‚úÖ' : '‚ùå'}\n\n`;
            
            reportText += `üéôÔ∏è VOICE SYSTEMS:\n`;
            reportText += `Microphone Stream: ${diagnostics.micStream ? '‚úÖ' : '‚ùå'}\n`;
            reportText += `Speech Recognition: ${diagnostics.speechRecognition ? '‚úÖ' : '‚ùå'}\n`;
            reportText += `WebKit Speech API: ${diagnostics.webkitSpeechRecognition ? '‚úÖ' : '‚ùå'}\n`;
            reportText += `Sound Detection: ${diagnostics.soundDetection ? '‚úÖ' : '‚ùå'}\n\n`;
            
            // Add recommendations
            if (successRate < 70) {
                reportText += `‚ö†Ô∏è RECOMMENDATIONS:\n`;
                if (!diagnostics.audioContext) reportText += `‚Ä¢ Click anywhere to activate audio context\n`;
                if (!diagnostics.micStream) reportText += `‚Ä¢ Allow microphone access when prompted\n`;
                if (!diagnostics.chatgptControl) reportText += `‚Ä¢ Try "Force Voice Mode" button\n`;
                if (!diagnostics.voiceSystem) reportText += `‚Ä¢ Use "Activate Voice" in control panel\n`;
            } else {
                reportText += `‚úÖ SYSTEM STATUS: GOOD\nMost systems are active and functioning.`;
            }
            
            showNotification('üîç Diagnostics Complete', reportText, 'info');
            
            // Auto-fix common issues
            if (!diagnostics.audioContext || diagnostics.audioContextState !== 'running') {
                console.log('üîß Auto-fixing audio context...');
                if (window.portalAudioContext) {
                    window.portalAudioContext.resume();
                }
            }
            
            if (!diagnostics.voiceSystem) {
                console.log('üîß Auto-activating voice system...');
                activateVoiceSystemImmediately();
            }
            
            if (!diagnostics.chatgptControl) {
                console.log('üîß Auto-retrying ChatGPT control...');
                attemptScriptInjection();
            }
            
            // Update button with results
            if (successRate >= 80) {
                btn.innerHTML = 'üîç Excellent!';
                btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
            } else if (successRate >= 60) {
                btn.innerHTML = 'üîç Good';
                btn.style.background = 'linear-gradient(135deg, #f39c12, #e67e22)';
            } else {
                btn.innerHTML = 'üîç Needs Fix';
                btn.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
            }
            
            setTimeout(() => {
                btn.innerHTML = 'üîç Full Diagnostics';
                btn.style.background = 'linear-gradient(135deg, #4a90e2, #2c5aa0)';
                btn.disabled = false;
            }, 5000);
        }

        // Quick system activation function
        function emergencyActivateAll() {
            console.log('üö® Emergency activation of all systems...');
            
            showNotification('üö® Emergency Activation', 'Force-activating all portal systems...', 'warning');
            
            // Force all flags to true
            window.chatgptControlActive = true;
            window.voiceSystemActive = true;
            window.speakerForceActive = true;
            window.soundDetectionActive = true;
            window.visualizationActive = true;
            
            // Force audio context
            if (window.portalAudioContext) {
                window.portalAudioContext.resume();
            }
            
            // Force voice system
            activateVoiceSystemImmediately();
            
            // Force ChatGPT control
            attemptScriptInjection();
            forceVoiceActivationAggressive();
            
            // Force speaker output
            forceSpeakerOutputEvent();
            
            // Force sound visualization
            startSoundVisualization();
            
            // Update all status indicators to active
            updateStatusIndicator('chatgptStatus', 'success', 'Emergency Active');
            updateStatusIndicator('speakerStatus', 'success', 'Emergency Active');
            updateStatusIndicator('voiceSystemStatus', 'success', 'Emergency Active');
            updateStatusIndicator('connectionStatus', 'success', 'Emergency Active');
            updateStatusIndicator('voiceModeStatus', 'success', 'Emergency Active');
            updateStatusIndicator('micStatus', 'success', 'Emergency Active');
            updateStatusIndicator('speechStatus', 'success', 'Emergency Active');
            
            setTimeout(() => {
                showNotification('üö® Emergency Complete', 'All systems have been force-activated. Check diagnostics for actual status.', 'success');
            }, 2000);
        }

        // Enhanced status checking
        function checkSystemStatus() {
            console.log('üìä Quick system status check...');
            
            const status = {
                audio: window.portalAudioContext && window.portalAudioContext.state === 'running',
                voice: window.voiceSystemActive && window.recognition,
                chatgpt: window.chatgptControlActive,
                speaker: window.speakerForceActive,
                microphone: window.micStream && window.micStream.active
            };
            
            const activeCount = Object.values(status).filter(Boolean).length;
            const totalCount = Object.keys(status).length;
            
            let statusText = `üìä Quick Status: ${activeCount}/${totalCount} systems active\n\n`;
            statusText += `üîä Audio Context: ${status.audio ? '‚úÖ' : '‚ùå'}\n`;
            statusText += `üé§ Voice System: ${status.voice ? '‚úÖ' : '‚ùå'}\n`;
            statusText += `ü§ñ ChatGPT Control: ${status.chatgpt ? '‚úÖ' : '‚ùå'}\n`;
            statusText += `üì¢ Speaker Force: ${status.speaker ? '‚úÖ' : '‚ùå'}\n`;
            statusText += `üéôÔ∏è Microphone: ${status.microphone ? '‚úÖ' : '‚ùå'}`;
            
            showNotification('üìä System Status', statusText, activeCount >= 3 ? 'success' : 'warning');
            
            return status;
        }

        // Helper functions
        function updateStatusIndicator(id, status, text) {
            const indicator = document.getElementById(id);
            const textElement = document.getElementById(id.replace('Status', 'StatusText'));
            
            if (indicator) {
                indicator.className = `status-indicator ${status}`;
            }
            
            if (textElement) {
                textElement.textContent = text;
            }
        }

        function showNotification(title, message, type = 'info') {
            const notification = document.createElement('div');
            const bgColor = type === 'success' ? 'rgba(39, 174, 96, 0.9)' : 
                           type === 'error' ? 'rgba(231, 76, 60, 0.9)' : 
                           type === 'warning' ? 'rgba(243, 156, 18, 0.9)' :
                           'rgba(52, 152, 219, 0.9)';
            
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${bgColor};
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                border: 1px solid rgba(255, 255, 255, 0.3);
                backdrop-filter: blur(10px);
                z-index: 10001;
                max-width: 350px;
                font-size: 0.9rem;
                animation: slideInRight 0.3s ease-out;
                white-space: pre-line;
            `;
            
            notification.innerHTML = `
                <strong>${title}</strong><br>
                <span style="opacity: 0.9;">${message}</span>
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.style.animation = 'slideOutRight 0.3s ease-in';
                    setTimeout(() => notification.remove(), 300);
                }
            }, 5000);
        }

        // Additional control functions
        function showVoiceControlPanel() {
            document.getElementById('voiceControlOverlay').classList.add('show');
        }

        function closeVoiceControl() {
            document.getElementById('voiceControlOverlay').classList.remove('show');
        }

        function showChatGPTControl() {
            document.getElementById('chatgptControlPanel').classList.add('show');
        }

        function closeChatGPTControl() {
            document.getElementById('chatgptControlPanel').classList.remove('show');
        }

        function startPortalMonitoring() {
            // Monitor all portal systems
            setInterval(() => {
                // Check ChatGPT connection
                const chatFrame = document.getElementById('chatgptFrame');
                if (chatFrame.src && !chatFrame.src.includes('about:blank')) {
                    updateStatusIndicator('connectionStatus', 'success', 'Connected');
                }
                
                // Monitor audio systems
                if (window.portalAudioContext && window.portalAudioContext.state === 'running') {
                    updateStatusIndicator('speakerStatus', 'success', 'Active');
                }
                
                // Check voice systems
                if (window.voiceSystemActive) {
                    updateStatusIndicator('voiceSystemStatus', 'success', 'Active');
                }
            }, 2000);
        }

        // Initialize speaker volume control
        function adjustSpeakerVolume(value) {
            if (window.portalSpeakerOutput) {
                window.portalSpeakerOutput.gain.value = value / 100;
                document.getElementById('audioRouteDisplay').textContent = `Audio Route: Phone Speaker (${value}% volume)`;
            }
        }

        // Legacy compatibility functions
        function updateSoundWaveVisuals(audioLevel) {
            // Convert old simple audio level to new analysis format
            const simulatedAnalysis = {
                bass: { avg: audioLevel * 0.6, peak: audioLevel * 0.8 },
                mid: { avg: audioLevel * 0.8, peak: audioLevel },
                treble: { avg: audioLevel * 0.4, peak: audioLevel * 0.6 },
                total: { avg: audioLevel, peak: audioLevel * 1.2 },
                patterns: { 
                    isRhythmic: audioLevel > 30,
                    isSpeech: audioLevel > 15 && audioLevel < 60,
                    isMusic: audioLevel > 25
                },
                intensity: Math.min(1, audioLevel / 255)
            };
            
            updateDynamicSoundWaves(simulatedAnalysis);
        }

        function activateSpeechVisualization() {
            const blackHoleContainer = document.getElementById('blackHoleContainer');
            blackHoleContainer.classList.add('speaking');
            
            // Trigger speech-like wave patterns
            const speechAnalysis = {
                bass: { avg: 20, peak: 30 },
                mid: { avg: 40, peak: 60 },
                treble: { avg: 25, peak: 35 },
                total: { avg: 30, peak: 50 },
                patterns: { isRhythmic: false, isSpeech: true, isMusic: false },
                intensity: 0.4
            };
            
            updateDynamicSoundWaves(speechAnalysis);
        }

        function deactivateSpeechVisualization() {
            const blackHoleContainer = document.getElementById('blackHoleContainer');
            const soundWaves = document.querySelectorAll('.sound-wave');
            
            setTimeout(() => {
                blackHoleContainer.classList.remove('speaking');
                soundWaves.forEach(wave => {
                    wave.classList.remove('active', 'bouncing', 'fast-ring', 'slow-ring', 'bass-responsive', 'treble-responsive');
                });
            }, 500);
        }
        function toggleSoundDetection() { 
            if (window.soundDetectionActive) {
                window.soundDetectionActive = false;
                window.visualizationActive = false;
                if (window.animationFrameId) {
                    cancelAnimationFrame(window.animationFrameId);
                }
                document.getElementById('audioVisualizer').classList.remove('active');
                document.querySelectorAll('.sound-wave').forEach(wave => wave.classList.remove('active'));
                showNotification('üé§ Detection Off', 'Sound detection deactivated.', 'warning');
            } else {
                window.soundDetectionActive = true;
                startSoundVisualization();
                showNotification('üé§ Detection On', 'Sound detection activated.', 'success');
            }
        }
        
        function refreshChatGPT() {
            const chatgptFrame = document.getElementById('chatgptFrame');
            chatgptFrame.src = 'https://chatgpt.com/c/685f5529-0888-800c-b96a-008419428418';
            showNotification('üîÑ Refreshing', 'ChatGPT portal refreshed.', 'info');
            
            // Re-establish control after refresh
            setTimeout(() => {
                establishChatGPTControl();
                initializeSpeakerForcing();
            }, 3000);
        }

        // Quick function implementations for all buttons
        function testSpeakerOutput() { forceSpeakerOutput(); }
        function calibrateAudioSystem() { runAudioDiagnostics(); }
        function injectChatGPTCommands() { forceChatGPTVoice(); }
        function emergencyReset() { location.reload(); }
        function testAudioLatency() { forceSpeakerOutput(); }
        function exportAudioSettings() { 
            const settings = {
                audioContext: !!window.portalAudioContext,
                chatgptControl: window.chatgptControlActive,
                voiceSystem: window.voiceSystemActive,
                speakerForce: window.speakerForceActive
            };
            console.log('Portal settings:', settings);
            showNotification('üíæ Settings Exported', 'Portal settings exported to console.', 'info');
        }
        function startFullVoiceMode() { activatePortalVoiceMode(); }
        function forceMicrophoneAccess() { bypassMicrophoneRestrictions(); }
        function setupVoiceBypass() { bypassMicrophoneRestrictions(); }
        function injectVoiceButton() { forceChatGPTVoice(); }
        function simulateUserClick() { forceChatGPTVoice(); }
        function sendPostMessage() { 
            const chatFrame = document.getElementById('chatgptFrame');
            chatFrame.contentWindow.postMessage({
                type: 'portal_control_message',
                action: 'activate_voice'
            }, 'https://chatgpt.com');
            showNotification('üì® Message Sent', 'PostMessage sent to ChatGPT.', 'info');
        }
        function forceIframeAccess() { injectPortalControlScript(); }
        function tryAlternativeControlMethods() { setupPostMessageControl(); }
        function initializeSpeakerForcing() { 
            setTimeout(() => {
                if (event && event.target) {
                    forceSpeakerOutput();
                } else {
                    // Auto-initialize speaker forcing
                    try {
                        if (window.portalAudioContext) {
                            window.portalAudioContext.resume();
                            updateStatusIndicator('speakerStatus', 'success', 'Auto-Initialized');
                        }
                    } catch (error) {
                        console.log('Auto speaker init error:', error);
                    }
                }
            }, 1000);
        }

        function monitorChatGPTAudio() {
            // Monitor for ChatGPT voice/audio activity
            console.log('Monitoring ChatGPT audio activity...');
            
            // Try to detect audio from ChatGPT iframe
            setInterval(() => {
                try {
                    // Check if there's any audio playing
                    if (document.querySelector('audio') || 
                        window.speechSynthesis.speaking ||
                        (window.audioContext && window.audioContext.state === 'running')) {
                        
                        // Trigger enhanced visualization for ChatGPT speech
                        activateChatGPTSpeechVisualization();
                    }
                } catch (error) {
                    // Silent error handling
                }
            }, 100);
        }

        function activateChatGPTSpeechVisualization() {
            // Special visualization when ChatGPT is speaking
            const blackHoleContainer = document.getElementById('blackHoleContainer');
            const soundWaves = document.querySelectorAll('.sound-wave');
            
            blackHoleContainer.classList.add('speaking');
            soundWaves.forEach(wave => {
                wave.classList.add('active');
                wave.style.borderColor = 'rgba(255, 215, 0, 0.8)'; // Gold color for ChatGPT
            });
            
            // Reset after a short time
            setTimeout(() => {
                soundWaves.forEach(wave => {
                    wave.style.borderColor = '';
                });
            }, 1000);
        }

        // Control functions
        function testSoundWaves() {
            const btn = event.target;
            btn.innerHTML = 'üåä Testing...';
            btn.disabled = true;
            
            // Activate all sound wave effects
            const soundWaves = document.querySelectorAll('.sound-wave');
            const audioVisualizer = document.getElementById('audioVisualizer');
            const blackHoleContainer = document.getElementById('blackHoleContainer');
            
            soundWaves.forEach(wave => wave.classList.add('active'));
            audioVisualizer.classList.add('active');
            blackHoleContainer.classList.add('speaking');
            
            // Animate all 28 audio bars with realistic frequency distribution
            const audioBars = document.querySelectorAll('.audio-bar');
            audioBars.forEach((bar, index) => {
                // Create a realistic frequency spectrum simulation
                let height;
                if (index < 7) {
                    height = 40 + Math.random() * 60; // Strong bass
                } else if (index < 14) {
                    height = 30 + Math.random() * 50; // Mid frequencies
                } else if (index < 21) {
                    height = 20 + Math.random() * 40; // High-mid
                } else {
                    height = 10 + Math.random() * 30; // Treble
                }
                
                bar.style.height = height + 'px';
                bar.style.animationDuration = (0.1 + Math.random() * 0.2) + 's';
                
                // Animate with color changes
                setTimeout(() => {
                    bar.style.height = (height * 0.7 + Math.random() * 20) + 'px';
                }, 200);
                
                setTimeout(() => {
                    bar.style.height = (height * 1.3 + Math.random() * 30) + 'px';
                }, 400);
            });
            
            btn.innerHTML = 'üåä 28 Bars Dancing!';
            btn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
            
            setTimeout(() => {
                soundWaves.forEach(wave => wave.classList.remove('active'));
                audioVisualizer.classList.remove('active');
                blackHoleContainer.classList.remove('speaking');
                
                btn.innerHTML = 'üåä Test Waves';
                btn.style.background = 'linear-gradient(135deg, #4a90e2, #2c5aa0)';
                btn.disabled = false;
            }, 3000);
        }

        // Additional control functions for compatibility
        function toggleSoundDetection() { 
            if (window.soundDetectionActive) {
                window.soundDetectionActive = false;
                window.visualizationActive = false;
                if (window.animationFrameId) {
                    cancelAnimationFrame(window.animationFrameId);
                }
                document.getElementById('audioVisualizer').classList.remove('active');
                document.querySelectorAll('.sound-wave').forEach(wave => wave.classList.remove('active'));
                showNotification('üé§ Detection Off', 'Sound detection deactivated.', 'warning');
            } else {
                window.soundDetectionActive = true;
                startSoundVisualization();
                showNotification('üé§ Detection On', 'Sound detection activated.', 'success');
            }
        }
        
        function refreshChatGPT() {
            const chatgptFrame = document.getElementById('chatgptFrame');
            
            showNotification('üîÑ Refreshing Portal', 'Reloading ChatGPT and re-establishing control...', 'info');
            
            // Reset systems before refresh
            window.chatgptControlActive = false;
            updateStatusIndicator('chatgptStatus', 'warning', 'Refreshing...');
            
            // Reload ChatGPT
            chatgptFrame.src = 'https://chatgpt.com/c/685f5529-0888-800c-b96a-008419428418';
            
            // Re-establish control after refresh
            setTimeout(() => {
                console.log('üîÑ Re-establishing control after refresh...');
                establishChatGPTControlAggressively();
                forceAllSystemsActive();
                
                showNotification('üîÑ Refresh Complete', 'ChatGPT refreshed and control re-established.', 'success');
            }, 5000);
        }

        function tryAlternativeControlMethods() { 
            setupPostMessageControl(); 
            setupAdvancedEventMonitoring();
            startContinuousPostMessage();
        }
        
        function initializeSpeakerForcing() { 
            setTimeout(() => {
                if (event && event.target) {
                    forceSpeakerOutput();
                } else {
                    // Auto-initialize speaker forcing
                    try {
                        if (window.portalAudioContext) {
                            window.portalAudioContext.resume();
                            updateStatusIndicator('speakerStatus', 'success', 'Auto-Initialized');
                        }
                    } catch (error) {
                        console.log('Auto speaker init error:', error);
                    }
                }
            }, 1000);
        }

        function toggleSettings() {
            const settingsPanel = document.getElementById('settingsPanel');
            settingsPanel.classList.toggle('show');
        }

        // Close settings panel when clicking outside
        document.addEventListener('click', function(event) {
            const settingsPanel = document.getElementById('settingsPanel');
            const settingsBtn = document.getElementById('settingsBtn');
            const voiceOverlay = document.getElementById('voiceControlOverlay');
            const chatgptPanel = document.getElementById('chatgptControlPanel');
            
            if (settingsPanel && settingsBtn && 
                !settingsPanel.contains(event.target) && 
                !settingsBtn.contains(event.target) &&
                !voiceOverlay.contains(event.target) &&
                !chatgptPanel.contains(event.target)) {
                settingsPanel.classList.remove('show');
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Portal control system ready');
            
            // Quick status check after load
            setTimeout(() => {
                checkSystemStatus();
            }, 3000);
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
            }
            if (window.portalAudioContext) {
                window.portalAudioContext.close();
            }
            if (window.micStream) {
                window.micStream.getTracks().forEach(track => track.stop());
            }
            if (window.recognition) {
                window.recognition.stop();
            }
        });
    </script>
</body>
</html>
